[{"title":"Ten minutes a day - 每天十分钟","date":"2019-03-26T12:02:17.000Z","path":"2019/03/26/tenminutes/","text":"每天十分钟就可以写完一本书，第一次翻译英文文章，锻炼英文。 2012 年初，我出版了 Jumping into C++。看了一下日历，我从 2010 年的一月份写到了 2012 年的一月份，但它只用了我不到 200 小时的工作量。我这么清楚这个时间是因为我始终仔细的追踪了我的工作时间。在 2010 年 1 月 4 日和 2011 年 9月 29 日这段时间（此时我停止了追踪），我写了接近 156 个小时和 70000 字。 那我是如何做到短时间内成功写完这本书呢？我有一个简单的原则，我必须每天写十分钟这本书的内容，每天，没有任何的借口。 最开始追踪时间的理由只有一个，就是希望通过连续的几天来鼓励自己，而且我认为不仅仅只是计算打卡天数那么简单。我会写下来具体我花费了多久的时间。它真的起作用了，我从来没有一天偷懒。 现在，我不会说我每天都有写这本书——只是说我在做这件事情。有时候，我会研究示例代码，调整一下格式，头脑风暴一波或者进行编辑。我需要做的事情就是，盯着页面十分钟，试着做一些事情感觉到自己在进步。 即使我是在写书的状态，我也没有在任何特定的一天写了特别久的时间——在 499 天中，我每天都写大概 15 分钟或甚至更少。只有其中 5 天我工作了超过一个小时，然后最长的写书时间是 72 分钟。它确实有助于我进入一种美好的状态，而从来不是那种立刻完成的状态（Jack Kerouac 说大概用了三周写完《On the Road》）。 因此，我进入了一种完全不同的状态——一个工作无所不在的世界，但是都在背后默默完成了。More sous vide than flame grilled。我在脑海中总是提醒自己要每天写作。当我完成了写作，我会带着自己的困惑到通勤路上或者淋浴间，我会和人们讨论这些困惑。我的想法总是很跳跃，很容易来回的改变。如果我每周六工作 70 分钟，我相信自己的进步会小得多。每次我准备开始的时候，我都会忘记自己在哪里。 在某些日子里，尽管如此，我还是会陷入困境。在那些日子，我允许自己做一些小调整，而不会强迫自己写大量的新内容。如果我有了作家之锁，我不会去强行打破这个锁——也许今天只是好的不够，所以不如做一点别的事情吧。明天总会有一些小缝隙时间来继续写作的。 在那些天，我总是检查和编辑几十页，这样似乎在激活我的灵感，通过提醒我书的大局和一些差距，以某种我做不到的方式（当我的光标停留在一句话的中间）。我很少发现自己不能连续写几天或一周。 另外一件对我很有帮助的事情是，只有我完成了写作，我才允许自己可以检查邮箱。在我读了一篇文章 http://dimitarsimeonov.com/2016/05/13/the-blinking-cursor-and-the-hot-towel 后我才意识到自己创建了一个习惯回路。我给自己检查邮件作为完成写作的奖励。它将写书这个概念和某件事情绑定在了一起，让它变得非常具体。这样子就没可能忘记写书了。 总有些时候，我觉得这本书不可能写完的，这本书就好像一座高山难以爬到山顶。但当这件事情真实发生的时候，回首过去做的事情，和编辑这本书，告诉了我，我已经走了这么远并鼓励我继续下一波工作。 所以，下一个十分钟你会做什么呢？ 原文作者：Alex Allain 原文链接： https://blog.usejournal.com/ten-minutes-a-day-e2fa1084f924 译者：Gin 编辑：Gin","tags":[{"name":"翻译","slug":"翻译","permalink":"http://yanjin.io/tags/翻译/"}]},{"title":"宝塔 + Github Page + Hexo 博客自定义域名上 https","date":"2019-03-25T12:02:17.000Z","path":"2019/03/25/https/","text":"Github Page 博客自定义域名上 HTTPS 备用方案，适用于特殊情况下利用 Github 的 Settings 的 enforce https 始终无法使用的情况。 问题自己 Github 博客仓库的的 Setting 的 enforce https 始终不能打勾，导致自己的自定义域名始终是 HTTP，作为一个 Geeker 怎么能容忍 HTTP 呢。 解决方法Github Repository Settings 添加 Custom domain将 Custom domain 设置为自己的域名即可，例如设置为 yanjin.io 添加域名解析记录在自己域名的服务商添加一条 A Record，host 设置为 @，表示指向一级域名，即 yanjin.io。Value 设置为自己服务器的 IP 地址。 服务器安装宝塔安装宝塔一句话代码1yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh 宝塔安装 LNMP 环境成功安装宝塔之后，会显示一个 URL，账号和密码，这个是进入宝塔界面的方法。进入首页之后，他会自动跳出来安装环境，我们选择安装 LNMP 环境，选择安装 Nginx 其实就够了，其他可以不用，勾选编译安装。 宝塔添加站点左边菜单栏-网站-添加站点，域名设置为自己之前自定义的域名，其他都可以选择不创建，PHP 版本设置为静态，点击提交。 点击设置，在网站页面最右边就可以看到设置按钮。 SSL-Let’s Encrypt-添加邮箱，文件验证即可，宝塔会自动帮你申请 SSL 证书。 生成完了就可以测试一下 HTTPS 域名了。如果测试成功，再勾选强制 HTTPS。 站点设置反向代理目标 URL 设置为如下所示，即自己Github Page的原始博客域名 1https://ttsy0001.github.io 发送域名设为如下所示，即自己的自定义域名 1yanjin.io 最后测试一下域名看看有没有跳转到博客即可！","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yanjin.io/tags/Hexo/"}]},{"title":"大四实习生拿到 Offer 备忘录","date":"2019-03-23T12:02:17.000Z","path":"2019/03/23/offer/","text":"以此作为未来找工作的提醒，切记切记，职场礼仪必备知识。 情况大四的时候面试过好几家公司，拿到了实习生 Offer，然后有一些大公司都是会通过邮件给自己发 Offer，他们都有一个 Offer 在线确认链接，你可以选择接受 Offer。 当时的处理方法当时决定放弃入职，以为只要不点击 Offer 在线确认链接即可。但后来入职当天，忽然 HR 打电话问我怎么没来，我就知道我做错事情了。 总结放弃 Offer 需即时联系 HR作为一个靠谱的人，下次决定放弃 Offer 的时候会先告诉 HR，系统有时候是不可信的。HR 可能以为你忘记点击确认链接了。 做一个厚道的人放弃 Offer 是很正常的事情，但是应该知道职场礼仪，即时通知相关的人，不要太过于相信系统。","tags":[{"name":"杂谈","slug":"杂谈","permalink":"http://yanjin.io/tags/杂谈/"}]},{"title":"实习找 bug 杂谈","date":"2019-03-21T12:02:17.000Z","path":"2019/03/21/internthoughts/","text":"纪念一下三个 bug 解决思路 需求利用 ansible 部署 mongoDB 踩坑对于代码读的不够多同事写的ansible 脚本设置了默认拥有 mongo 账户，要有 sudo 权限，自己一直没仔细看脚本找到原因。 一直报错：权限不够 mongoDB 安装程序版本当时使用的 Ubuntu 作为服务器，部署这个 mongoDB 的服务端一直提示错误。我将命令直接复制到远程机器进行测试，提示缺少某个共享库。 所以当时的思路就是直接百度，缺少这个共享库的报错如何解决。 但是百度了一圈感觉不太对，因为大家都认为是因为缺少安装了某个插件。 后来让同事过来看，原来是自己用的 mongoDB 安装程序版本没有对应上自己 Ubuntu 的版本，这样子也是会报错的。 shell 脚本转义ansible 执行远程 shell 命令 kill 进程 因为 shell 脚本里面涉及到了一个 $ 符号，脚本一直提示参数错误。 我当时的解决思路是，直接复制那句脚本到远程机器跑，没有任何问题。因此很纳闷，还以为又是没有 sudo 权限导致的错误 实际上是因为 shell 脚本需要对 $ 符号进行转义，加一个 / 符号即可 总结对数字要敏感我当时确实看到了这个 mongoDB 安装程序脚本对不上，但是自己上官网寻找软件的时候，竟然没找到对应版本，迫不得己又下了一个别的版本。 新的版本因为也不是对应 Ubuntu 的，所以还是一样报错。 所以当时思路是对的，可惜没坚持下去。应该再仔细翻一下官网找到正确的安装包。 不要问同事太傻的问题个人认为上述两个问题都问同事解决有点傻。因为是自己的粗心大意导致的，记录下来就是要勉励自己，变得靠谱一点，不要浪费其他人的时间。 实在解决不了才问同事因为一旦这个问题卡住太久了，时间就被浪费了。可能问同事五分钟，就可以等于你的一天。 比如说那个 shell 脚本转义的问题，我一直没找到解决的思路。但是如果你写过 shell 脚本或者踩的坑多了，你自然而然就知道如何解决。 高手就是碰到过各种各样的坑写的代码足够了，坑踩的足够多了，记录下来并总结，你也会成为高手。","tags":[{"name":"Python","slug":"Python","permalink":"http://yanjin.io/tags/Python/"}]},{"title":"双网卡配置同时访问内网外网","date":"2019-03-02T16:02:17.000Z","path":"2019/03/03/networkcard/","text":"这个方案适用于内网，自己可以买一个无线网卡，连接自己的 Wi-Fi 热点实现外网的访问。 条件1.无线网卡（免驱动版本：即插入后自带驱动自行安装） 2.流量较多的手机卡可以 Wi-Fi 热点 环境 Win10 TP-LINK TL-WN726N 免驱版 USB 无线网卡 知识点 网关 在计算机网络中，网关（英语：Gateway）是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。 简单的理解来看，网关就是一个网络连接到另一个网络的“关口”。 默认网关是指不管流量去往哪里，如果没有指定去向，那么流量就会被引入默认网关指向的 IP。而我们现在有两块网卡都设置了默认网关(可能是你自己设置的，也可能是 DHCP 分配的)，并且他们的指向是不同的，这就导致流量不知道到底去往哪个默认网关，结果就是所有网站都无法正常访问。 子网掩码 子网掩码 (subnet mask) 又叫网络掩码、地址掩码、子网络遮罩，是一个应用于 TCP/IP 网络的 32 位二进制值。它可以屏蔽掉 IP 地址中的一部分，从而分离出 IP 地址中的网络部分与主机部分，基于子网掩码，管理员可以将网络进一步划分为若干子网。它必须结合 IP 地址一起使用。 步骤1.安装网卡驱动插入网卡后，点击对应的 U 盘，里面自带驱动程序。 2.查看内网配置目的是为了获取公司内网的网关，和自己的内网 IP 地址。 1ipconfig /all 3.添加内网路由策略例如通过第二步可以看到自己的内网 IP 地址是 10 开头的，那么我们就把这一整个 10 开头的网段设置为内网的网关。 打开 CMD，输入以下这段静态路由命令。 1route -p add 10.0.0.0 mask 255.0.0.0 10.0.0.254 -p 是指永久添加到路由表；第一个 IP 段是你的内网网段；第二个是子网掩码，3 类私有地址段情况不同；第三个 IP 地址是你内网的默认网关。 另外两类内网地址的静态路由命令可供参考12route -p add 192.168.0.0 mask 255.255.255.0 192.168.0.1route -p add 172.16.0.0 mask 255.255.0.0 172.16.0.254 4.设置外网流量优先请通过 Win10 桌面右下角的网络设置，进入设置页面。选择显示所有可用的网络，打开外网网卡的 IPV4 设置，选择”高级”，去掉”自动跃点”，手工填写跃点数为”1”，保存退出。 这里的跃点数是越小，优先级越高。 5.测试首先可以通过进入一些可以查询自己 IP 地址的网站看看自己是不是手机流量的 IP，再随便测试一下内网的页面访问能否正常即可。 参考链接ROUTE命令配置路由策略使双网卡可以同时访问内网和外网子网掩码详解","tags":[{"name":"网络","slug":"网络","permalink":"http://yanjin.io/tags/网络/"}]},{"title":"搭建属于自己的Google-反向代理Google","date":"2019-02-07T12:02:17.000Z","path":"2019/02/07/yourgoogle/","text":"公司里面用不了 VPN，不能科学上网？那不如搭建一个自己专用的 Google 网站，不翻墙也可以科学搜索了！ 缘由公司网络有限制，VPN 设置了之后也连接不上服务器。自己又没有公司内网里面海外服务器，幸亏看到这个反向代理 Google 方法了，简直拯救了我！ 条件1.海外 VPS 一台（实测：DigitalOcean） 2.域名一个 推荐 Vultr 和 DigitalOcean，DigitalOcean有学生优惠，利用 Github 的学生包（有学生邮箱注册即可）可以免费获得 DigitalOcean 60 刀，可以免费用一年 5 刀每月的服务器。 DigitalOcean：注册链接通过我的链接注册可以直接获得 10 刀！付款方法支持 Paypal，只需要绑定一张银行卡就可以付款优势：一旦 IP 被墙，备份一下服务器，删除服务器，重新创建一个即可获得新的IP Vultr：注册链接Vultr 按小时计费，可以自己换 IP，最低 3.5 美元/月，新用户注册就送 30 美元（有限期一个月），分享到 Twitter 再赠送 3 美元，支持支付宝和微信支付，非常适合新手用户 环境 1 GB Memory / 25 GB Disk / SFO2 CentOS 7.5 x64 确保是干净的操作系统，没有安装过其它环境带的Apache/Nginx/php/MySQL 步骤1.一键安装宝塔1yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh 2.宝塔安装 LNMP 环境成功安装宝塔之后，会显示一个URL，账号和密码，这个是进入宝塔界面的方法。进入首页之后，他会自动跳出来安装环境，我们选择安装 LNMP 环境，FTP的可以不用勾选，选择极速安装即可 3.域名解析服务器 IP在使用反向代理之前必须要把 A 记录解析到需要反代的服务器 IP 地址。这一步进入到自己的域名服务商那里添加解析记录。 4.新建站点宝塔控制面板首页-网站-添加站点域名添加自己的域名，点击提交 5.反向代理设置在站点的页面，选择设置，选择反向代理目标URL设置为 1https://www.google.com.hk 发送域名设置为1www.google.com.hk 最后点击保存 6.添加 SSL 证书目的是增加自己这个镜像网站被墙的难度。在线申请免费 SSL 证书，在这里申请一个免费证书在站点的页面，选择设置，选择 SSL - 其他证书将下载的 private.key 文件中的值添加到密钥，full_chain.pem 文件中的值添加到证书，保存！设置强制 HTTPS，这样子访问 HTTP 网址后也会自动跳转到HTTPS页面 7.重启网站网站-状态-关闭-开启，即成功重启。最后输入自己的域名测试 参考链接宝塔面板nginx反向代理教程Linux安装宝塔面板一键反向代理谷歌","tags":[{"name":"VPS","slug":"VPS","permalink":"http://yanjin.io/tags/VPS/"}]},{"title":"Django REST framework 利用 Token 实现登陆API","date":"2019-01-24T12:02:17.000Z","path":"2019/01/24/djangoToken/","text":"本文优化了 Django REST framework 的 Token 模块，实现登陆即更新一次 Token，修复了 Django Token 千年不变的问题，并且实现了先从缓存中获取 Token，如果没有再从数据库中取出来的缓存机制。 版本说明123Python3Django==2.0rest_framework==3.9 Django 后端设置settings.py假如 Django 工程名为 platform，那么项目根目录下会有一个 platform 文件夹，首先需要修改工程的配置文件settings.py文件，在 INSTALLED_APPS 中添加了两个模块，rest_framework 和 rest_framework.authtoken。还增加了 REST_FRAMEWORK 的配置内容。 里面有三个属性，可以从英文名看出来是什么意思。DEFAULT_AUTHENTICATION_CLASSES 指的是默认认证类，即确定你是谁。代码里面添加了两个类，第一个表示的是BasicAuthentication认证方式，即传统的账号密码登陆。第二个是自己重写了继承 rest_framework.authentication.BaseAuthentication 这个类的内容，在这个 ExpiringTokenAuthentication 类中实现从缓存中获取 Token，如果没有再从数据库中取出来。 DEFAULT_PERMISSION_CLASSES 指的是默认访问权限，在确定了你是谁之后，还要确定一下你的权限，即你能干什么，官方名字叫做鉴权。这里设置了所有 API 的默认权限都必须是认证之后才可以访问。 DEFAULT_RENDERER_CLASSES 指的是默认返回类型，设置为 rest_framework.renderers.JSONRenderer 的目的是只返回 JSON 格式，之前框架自带的 API 页面就没有了。 12345678910111213141516171819202122232425INSTALLED_APPS = [ 'django.contrib.admin', 'django.contrib.auth', 'django.contrib.contenttypes', 'django.contrib.sessions', 'django.contrib.messages', 'django.contrib.staticfiles', 'rest_framework', 'rest_framework.authtoken', 'account']REST_FRAMEWORK = &#123; 'DEFAULT_AUTHENTICATION_CLASSES': [ 'rest_framework.authentication.BasicAuthentication', 'account.auth.ExpiringTokenAuthentication', #'rest_framework.authentication.TokenAuthentication', ], \"DEFAULT_PERMISSION_CLASSES\": [ \"rest_framework.permissions.IsAuthenticated\", ], 'DEFAULT_RENDERER_CLASSES': ( 'rest_framework.renderers.JSONRenderer', )&#125; auth.py下面是 ExpiringTokenAuthentication 这个类的具体实现代码，代码经测试可运行。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970\\account\\auth.pyimport pytzfrom django.utils.translation import ugettext_lazy as _from django.core.cache import cacheimport datetimefrom rest_framework.authentication import BaseAuthenticationfrom rest_framework import exceptionsfrom rest_framework.authtoken.models import Tokenfrom rest_framework import HTTP_HEADER_ENCODING# 获取请求头里的 token 信息def get_authorization_header(request): \"\"\" Return request's 'Authorization:' header, as a bytestring. Hide some test client ickyness where the header can be unicode. \"\"\" auth = request.META.get('HTTP_AUTHORIZATION', b'') if isinstance(auth, type('')): # Work around django test client oddness auth = auth.encode(HTTP_HEADER_ENCODING) return auth# 自定义的 ExpiringTokenAuthentication 认证方式class ExpiringTokenAuthentication(BaseAuthentication): model = Token def authenticate(self, request): auth = get_authorization_header(request) if not auth: return None try: token = auth.decode() except UnicodeError: msg = _('Invalid token header. Token string should not contain invalid characters.') raise exceptions.AuthenticationFailed(msg) return self.authenticate_credentials(token) def authenticate_credentials(self, key): # 增加了缓存机制 # 首先先从缓存中查找 token_cache = 'token_' + key cache_user = cache.get(token_cache) #print(cache) if cache_user: print('cache token get!') return (cache_user.user, cache_user) # 首先查看 token 是否在缓存中，若存在，直接返回用户 try: token = self.model.objects.get(key=key[6:]) except self.model.DoesNotExist: raise exceptions.AuthenticationFailed('Invalid request') if not token.user.is_active: raise exceptions.AuthenticationFailed('Invalid user') utc_now = datetime.datetime.utcnow() if (utc_now.replace(tzinfo=pytz.timezone(\"UTC\")) - token.created.replace(tzinfo=pytz.timezone(\"UTC\"))).days &gt; 1: # 设定存活时间 1 天 raise exceptions.AuthenticationFailed('Invalid token') if token: token_cache = 'token_' + key cache.set(token_cache, token, 24 * 1 * 60 * 60) # 添加 token_xxx 到缓存，缓存保存时间为 1 天 return (token.user, token) def authenticate_header(self, request): return 'Token' 从上面这个代码可以看出来，我们后端所有的 API 请求，都会从请求的 Headers 中取出来 AUTHORIZATION 字段 登陆函数代码中加有注释，很好理解，主要工作就是通过 user 拿到 Token，然后删除 Token，再重新创建它。可以看到登陆函数加了 permission_classes 和 authentication_classes，设置为空就是为了覆盖之前的默认设置，所有人不需要 Token 值也可以访问这个登陆 API。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354from rest_framework.views import APIViewfrom rest_framework.authtoken.models import Tokenfrom django.contrib.auth import authenticateimport jsonclass LoginView(APIView): permission_classes = [] authentication_classes = [] @get_request_args def post(self, request, args): print(args) username = args.get(\"username\") password = args.get(\"password\") print(username) print(password) user = authenticate(username=username, password=password) if user is not None and user.is_active: # 更新token值 token = Token.objects.get(user=user) token.delete() token = Token.objects.create(user=user) success_content = &#123; \"token\": token.key, &#125; test = json.dumps(success_content) #return JsonResponse(success_content, status=status.HTTP_200_OK) return Response(success_content, status=status.HTTP_200_OK) else: error_content = &#123; \"detail\": 'Invalid username or password', &#125; return Response(error_content, status=status.HTTP_401_UNAUTHORIZED) def get_request_args(func): def _get_request_args(self, request): if request.method == 'GET': args = request.GET else: body = request.body if body: try: args = json.loads(body) except Exception as e: print(e) # return makeJsonResponse(status=StatusCode.EXECUTE_FAIL, message=str(e)) args = request.POST else: args = request.POST return func(self, request, args) return _get_request_args urls.py利用 Django REST framework 的 APIView 生成对应的API 12345from account import apiurlpatterns = [ url('login-demo/', api.LoginView.as_view()),] 前端请求格式我们前端所有的 API 请求，都需要在请求的 Headers 中添加 AUTHORIZATION 字段，AUTHORIZATION 的值为 Token 加一个空格，再加上真正的 Token 值。1AUTHORIZATION:Token 8ba11785d9700b7bc1a311428e6c3a3fe16e9145","tags":[{"name":"Django","slug":"Django","permalink":"http://yanjin.io/tags/Django/"}]},{"title":"Django 执行原始 SQL 语句参数化查询-预防 SQL 注入","date":"2019-01-21T12:02:17.000Z","path":"2019/01/21/performingRawSQLqueries/","text":"Django 原始 SQL 语句参数化查询，包括 like 模糊查询 缘由实习内容：开发一个数据库运维系统 需求：因为我们操作的是远程的数据库，包括Oracle、MySQL、MongoDB，有大量的查询语句需要直接用到raw SQL语句，这里不适合Django的模型 ORM 操作 后端语言：Python3 框架：Django2.0 &amp; Django REST framework 实践1.创建 SQL 文件我们以Table 搜素为例，首先是创建一个 SQL 文件，我们通过直接调用文件中的 SQL 语句增加代码整洁性。比如说，对于 Oracle 下的所有 SQL 文件我都会放在一个文件夹中。 需要搜素的参数值我们设置为 %s，如下面的代码所示， 12SELECT OWNER,TABLE_NAME,TABLESPACE_NAME,STATUS,LOGGING,NUM_ROWS,BLOCKS,DEGREE,LAST_ANALYZED,TEMPORARY from dba_tables WHERE owner like %s And table_name like %s order by OWNER,TABLE_NAME asc^EOF 如果SQL 语句此时里面有需要用到的百分号,需要双写百分号，如下面的代码所示 1SELECT foo FROM bar WHERE baz = '30%%' AND id = %s 2.读取 SQL 文件split()：用于拆分字符串。通过指定分隔符对字符串进行切片，并返回分割后的字符串列表（list）。 strip()：用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。 1234567def get_sql(sql_file): with open(sql_file, 'r') as fr: sql = fr.read().split('^EOF')[0].strip() return sql sql_file = \"oracle/sql/index_parameters_sessions_detail_search.sql\"sql = get_sql(sql_file) 3.参数赋值like 模糊参数需要将搜素的参数设置格式为 %test%，test修改为我们搜素的值噢 1params = [\"%&#123;&#125;%\".format(owner.upper()), \"%&#123;&#125;%\".format(table_name.upper())] 如果不是like 查询,我们的参数的形式为 list 即可 1params = [username] 4.执行 SQL1cur.execute(sql, params) 官方样例代码123456789from django.db import connectiondef my_custom_sql(self): with connection.cursor() as cursor: cursor.execute(\"UPDATE bar SET foo = 1 WHERE baz = %s\", [self.baz]) cursor.execute(\"SELECT foo FROM bar WHERE baz = %s\", [self.baz]) row = cursor.fetchone() return row 参考链接Django 文档","tags":[{"name":"Django","slug":"Django","permalink":"http://yanjin.io/tags/Django/"}]},{"title":"hexo-theme-indigo 博客评论系统 Valine 配置","date":"2019-01-20T12:02:17.000Z","path":"2019/01/20/blogValine/","text":"适用于想更换主题为 hexo-theme-indigo 的朋友，本篇文章可以带你如何正确的配置 hexo-theme-indigo 的评论系统Valine 缘由花费了一个下午和晚上折腾博客，因为之前用的主题 Next 行间隔太大了，字体又小小的，自己看的不是很舒服，就想换一个主题，所以换成了 hexo-theme-indigo 这个主题。 折腾过程中官网没有给出配置博客评论系统的代码，我用之前主题 Next的 Valine配置怎么都显示不出来，最后搜索到一篇文章终于发现了不同的地方，hexo-theme-indigo里面的配置中是 appId，不是 appid。 方法修改博客对应的主题目录的配置文件，例如blog/themes/indigo/_config.yml，直接添加下方代码即可，修改对应的 id 和 key 值为自己 Leancloud 的。 代码12345678910valine: enable: true # 如果你想使用valine，请将值设置为 true appId: # your leancloud appId appKey: # your leancloud appKey notify: true # Mail notify verify: false # Verify code avatar: mm # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide placeholder: Just go go # Comment Box placeholder guest_info: nick,mail # Comment header info pageSize: 10 # comment list page size 参考链接hexo-theme-indigoValine","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yanjin.io/tags/Hexo/"}]},{"title":"威胁猎人初级安全实习生面经","date":"2018-11-15T01:42:58.897Z","path":"2018/11/15/interviewThreadHunter/","text":"公司在深圳，办公环境很好，前台小姐姐很漂亮，有程序猿鼓励师猫猫一只，方向我也很喜欢，打击黑灰产。 面试时间及岗位时间：2018 年 11 月 9 日 下午 4 点 岗位：威胁猎人初级安全实习生 技术官一面技术官主要是看了我的简历，开始说道他也是通信工程毕业的，知道我们电子信息科学与技术学什么，知道我们学的很杂哈哈。 然后问了我下面几个问题： 1.OSI 七层模型是哪七层？（没答出来全部，记得一两个） 2.有没有用过 Linux 系统 3.Cat 命令和 Grep 命令的使用方法，比如说考了我如何匹配搜索两个 TXT，一个 TXT 文本里面有很多 ip 地址，另外一个 TXT 文本里面包含了很多黑产的监控流量有 ip 地址，发送数据包之类的 4.是否了解黑产和灰产，让我说说自己知道的 我回答了猫池，还有物联网 IOT 的肉鸡 DDOS 攻击，打码平台，薅羊毛党啊等等 然后技术官就跟我介绍了他们这个部门主要做啥 CTO二面当时大佬一进来我就震惊了，我以为一面就可以了，我只是面一个实习生咋还跑出来大佬呢 1.什么时候开始学安全的（我回答今年年初） 2.设计一个登陆注册的系统有什么要考虑的地方 要有验证码功能，而且最好用现在比较难以破解的验证码，比如 Google 和网易的验证码。 密码也应该有强度要求，然后不能直接明文发生登陆或者注册请求到服务器，要加盐加密传输，数据库存储也应该是加盐加密保存，防止被脱裤之后明文裸奔 参数还要带有 csfr_token 值防止 CSRF 攻击 cookie 中要设置 HttpOnly 属性，那么通过 js 脚本将无法读取到 cookie 信息，这样能有效的防止 XSS 攻击 对于参数的输入要进行参数化参训防止SQL注入 3.https 能不能被破解 我说可以，就是在客户端或者服务器端劫持，替换了证明就可以看到 https 明文传输的内容。但是 CTO 指出来这是因为你用了抓包工具，而且还是在网站没有校验证书的情况下，如果校验的话中间人劫持也没用 4.我简历上学校正方的漏洞是怎么挖到的 5.自己还有投别的公司拿到 offer 吗？（我说还投了一家教育公司，他就有点怀疑我是不是真的喜欢安全了，这里建议不要回答不相关的） 6.问我如果数据库被脱裤了，有什么处理方案 一赶紧溯源攻击，找到入侵者，然后寻找是否这个数据库是否在网上公开，要即可减少被售卖或者公开的机会 二是告诉用户，提醒用户改密码 面试的时候，大佬眉头一直紧皱的看着我的简历，让我很害怕 HR面HR面就没问啥了，问我期望薪水。我说 4k-5k 然后似乎被嘲笑了哈哈，说实习生工资没有这么高的，进来主要是学东西。 还问我几时可以到岗，最后是拿到这个实习生 offer 啦！","tags":[{"name":"面试","slug":"面试","permalink":"http://yanjin.io/tags/面试/"}]},{"title":"携程测试实习生面经","date":"2018-11-15T01:42:58.897Z","path":"2018/11/15/interviewCtrip/","text":"一个啥也不会的菜鸡强行转测试的面试经验 面试时间及岗位时间：2018 年 11 月 14 日 晚上 6 点 岗位：携程测试实习生 HR一面1.是否找到了实习，因为捞我的简历起来已经过了一个星期，怕我已经找到实习了 2.还问我是否愿意接受测试的岗位，因为看到我之前有做过一些开发项目 3.约技术面试时间 技术官二面1.自我介绍一下 2.让我依次介绍我的项目干了什么 3.让我看一段代码，代码就不放出来，可能涉及公司隐私，不难 4.让我打开携程首页，问我一个机票的界面这里需要测试什么 然后面试官问我还有什么要问的吗？我就问还要不要继续面试，她说没有了，基本可以了，问我几时可以到岗，最长可以实习多久 总结想去携程是因为感觉公司比较大，投测试是因为比较好进，开发岗位的话自己基础不够好很容易给刷，但是还没考虑好去不去携程。","tags":[{"name":"面试","slug":"面试","permalink":"http://yanjin.io/tags/面试/"}]},{"title":"360企业安全实习生面经","date":"2018-11-15T01:42:58.897Z","path":"2018/11/15/interview360/","text":"360企业安全-福建分公司安全实习生面试经验 面试时间及岗位时间：2018 年 11 月 17 日 下午 4 点 岗位：360企业安全实习生 技术官面1.是否还有课，论文什么时候答辩 2.看我比较擅长 Python，问我有没有搭过什么系统 搭过公众号开发的一个查询功能 3.有没有写过爬虫或者什么漏洞利用工具（ EXP 和 POC ） 写过 Python 爬虫，抢课代码，没写过 EXP 和 POC 4.Linux 进程如何查看？ 我回答 ps -a,但是应该回答 ps aux 更好 5.Windows 安全日志在哪里？ 当时没回答出来 答案：计算机 - 管理 - 事件查看器 - Windows 日志 - 安全 6.目前有用过哪些扫描器？ Nmap、AWVS、sqlmap、BurpSuite 当时回答 BurpSuite 说没有扫描功能很尴尬，技术官指出来说 BurpSuite 是现在最好用的扫描器，集成了各种功能，抓包解码重放爆破 7.有没有实习过 没有实习过，刚找实习，面试官因此就问我过去新环境有没有问题 我回答之前社团工作了两年，经常与人沟通，适应能力很好 8.任意文件读取漏洞产生的原理 下载功能或者读取文件时候没有对权限进行控制，允许它跳转到 WEB 目录 9.任意文件读取漏洞正常出现在什么功能点？ 下载功能或者读取文件，查看一些文件的时候 10.XSS 原理 XSS 有三种类型(反射型、存储型、DOM 型)，原理是因为没有过滤客户端提交的数据，被利用后回显到平台 11.有没有利用过 XSS 平台 没有…… 12.目前有接触过什么病毒木马吗 WannaCry病毒 13.病毒环境有哪些特征？病毒的一些特征（除了勒索软件，比如挖矿有什么特征） CPU利用资源特别高、不停的发包 面试官解释这属于网络行为，挖矿会请求矿池，可以通过抓包的方式观察是不是一直在访问矿池，可以确认是不是有挖矿行为 本机上可能有蠕虫行为、肯定会扩散，植入一堆挖矿病毒 本机上以防你删除掉查杀掉，还会有一些自启动服务防止被删除 14.祖籍在哪里 15.平时有没有处理过 EXCEL 和 WORD，有没有做过一些数据统计或者数据分析 有的，用过Python数据分析，EXCEL基本操作快捷键都会 16.EXCEL函数有用过哪些？ sum、mid、count、if、lookup 17.是不是打算走普通实习，要不要考虑走校招，再过两轮面试 走实习，我就问有没有机会转正，面试官说有，看实习表现 18.问我有没有用过 Java 没有 19.问我有没有考虑过在家那边找工作","tags":[{"name":"面试","slug":"面试","permalink":"http://yanjin.io/tags/面试/"}]},{"title":"金山服务端开发实习面试总结","date":"2018-05-14T02:42:19.000Z","path":"2018/05/14/interviewWPS/","text":"人生中的第一次面试打击，但是收获也很大！ 面试时间及岗位时间：2018 年 5 月 14 日 上午 10 点 岗位：金山办公软件服务端开发工程师实习生 面试问题以下文字和面试时候问题不一定一摸一样，靠记忆补充的。 问：你会 CSS3 吗？ 答：不会 问：你会 JS 吗 答：不会 问：那这个岗位需要这两个技能啊 答：但是我可以很快学习这两个，我自学能力比较好。比如说我做的那个微信公众号查询形势与政策的功能，只花了 10 天左右。 问：一般人学 Python 3 天就够啦 我：…… 面试官看了看我项目的经历写着创业基础一键刷课，抢课助手。问我为什么要写这些程序，创业基础课程本来就是学生要学生听课的，你这样子等同于作弊。 我：…..（我就是想锻炼一下技术，帮帮别人。但是面试官说的太有道理了，我没话说，只好赞同。这种课上了有啥用？） 面试官：你这个是政治不正确 我：…… 面试官：你为什么要写这个教学平台的一键查询程序呢？ 我：为了方便大家查询，之前同学们如果有几门作业未提交，就需要一个一个点进去看，很不方便。我的这个程序可以直接一次显示完全部科目的未提交作业。 面试官：那你这样为什么不直接跟开发厂商反应，让他们提升用户体验呢？你现在这个程序有人用吗？写了几天花费这么多时间，但是没有实际用途。 我：我想过写成微信小程序给大家用…… 面试官：你为什么要在你的简历上写这么多社团经历，在大学里面花这么多时间去社团，这些社团经历跟你写代码有关系吗？ 我：但是加入了社团锻炼了我沟通能力，社交能力啊。 面试官：那这些能力和写代码能力有关系吗？ 我：…… 我：面试官，那我给您看看我的成绩单。之前因为在社团也没有好好学习，但现在退出后一直在好好学习，每学期都在进步，从 2.6, 3.1, 3.5 再到 4.1 。说明我的学习能力还是可以的。 面试官：但是你可以看看班上一些女孩子，学习成绩很好，但是写代码不行啊。这个也跟写代码能力没有关系。 我：…… 面试官：那还是来点实际的，你说一下二分查找的算法。 我：一开始说了直接从中间开始查找，但是根本还没排序。想到排序了，但是不会写冒泡排序的算法了。 没答出来面试官就直接走了，说面试结束。我知道自己肯定挂了，等了许久 HR 也没来，我就直接走了。 总结1.刷题刷题刷题！我的数据结构一点都没学，也没去刷题，这个是面试失败最根本的原因。我之前复习的策略都在简历上的知识点，没有弄面试的算法题，这个致命伤。 2.简历上的项目不要写那些带有违反规定或者政治不正确的项目。比如我这次的抢课助手和刷课项目，我也得承认这两个东西违反了一些规定，但是学技术的人难道就没有 Geek 精神吗？你可以测试，但是不能有盈利就好了。 3.社团经历如果是面试技术岗位，能不写还是不写了吧。面试官对社团经历的个人偏好完全影响了他对你的个人印象。有的面试官可能喜欢社会实践经验多的，有的面试官完全不喜欢。 说到社团就是一把辛酸泪，感觉两年的付出给这个面试官全抛否定了。但我知道我收获了什么，见世面，沟通能力，协调能力，这是写代码能带来的？ 不是，这些能力才是社会上更重要的技能。 写代码是一定要很熟练的，但是只会写代码是不行的。 不过也看得出来，我现在是连写代码都不会的人哈哈哈！本末倒置。 4.大学成绩金山的这个面试官不看重成绩，看重的是写代码的能力。 我也知道一个朋友的朋友，就会因为项目经验多，写代码能力强去了小米。虽然挂科很多，成绩很差。 这也从侧面体现出了互联网公司对于大学成绩的看法。 但是从我自己的角度来看，如果想继续读研究生，成绩还是非常重要的。你有成绩至少有几条路可以选，没有成绩就只能工作了，或者你很有钱去国外留学。","tags":[{"name":"面试","slug":"面试","permalink":"http://yanjin.io/tags/面试/"}]},{"title":"微信公众号推文永久链接爬虫","date":"2018-04-26T03:41:18.000Z","path":"2018/04/26/wechatArticleSpider/","text":"利用微信公众号后台素材管理－新建图文素材－超链接－查找文章（公众号）的接口实现爬取公众号的所有文章链接 需求获取某个或多个微信公众号的所有文章，并且文章的链接是永久链接。比如我之前想分析学校公众号的某一个长期栏目，就需要他所有相关推送的文章内容。但是有 100+ 的推送，总不可能一篇一篇文章的去保存它的链接对吧？因此要想办法自动获取到所有的链接，再通过打开链接得到文章内容。 原理利用微信公众号后台素材管理－新建图文素材－超链接－查找文章（公众号）的接口。因此，我们要做的就是模拟这个请求。1.Selenium ＋ Webdriver 登陆微信公众平台，获取公众号的Cookie2.登陆之后获取 token 值，因为之后所有请求都需要带 token 这个参数3.模拟搜索公众号，每个公众号有对应的 fakeid，我们要得到公众号的fakeid4.模拟搜索公众号内的文章，self.query 这个值为搜索公众号文章的关键字，默认为空，可以修改为自己想要找的公众号文章标题对应的关键字。此时会返回一个 JSON 包，app_msg_list 中的 link 就是我们要的链接。 前提你要有一个自己的微信公众号（订阅号）Python环境：Python3 方法修改 wechat_official_accounts 为想要搜索公众号的微信号，支持多个微信号修改 username 为自己订阅号的账号修改 password 为自己订阅号的密码修改 self.query 为自己想要搜索的公众号文章标题对应的关键字修改 self.driver = webdriver.Firefox(executable_path=’/Users/zl/Downloads/geckodriver’) 为自己对应的 geckodriver 内核地址，也可以使用 Chrome 浏览器 代码Talk is cheap，show you my code。Github 项目代码地址: https://github.com/ttys0001/wechat-spider 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118import timeimport requestsimport jsonimport reimport randomfrom selenium import webdriverclass WechatArticleUrl: def __init__(self,wechat_official_accounts,username,password): self.wechat_official_accounts = wechat_official_accounts self.article_url_list = [] self.driver = webdriver.Firefox(executable_path=&apos;/Users/zl/Downloads/geckodriver&apos;) self.account_str = [username, password] self.cookies = &#123;&#125; self.token = &apos;&apos; self.header = &#123; &quot;HOST&quot;: &quot;mp.weixin.qq.com&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:53.0) Gecko/20100101 Firefox/53.0&quot; &#125; self.query = &apos;&apos; def __main__(self): self.login_wechat_official() self.get_token() self.get_url() def login_wechat_official(self): self.driver.get(&apos;https://mp.weixin.qq.com/&apos;) time.sleep(2) # ============登录，获取cookie self.driver.find_element_by_name(&apos;account&apos;).clear() self.driver.find_element_by_name(&apos;account&apos;).send_keys(self.account_str[0]) self.driver.find_element_by_name(&apos;password&apos;).clear() self.driver.find_element_by_name(&apos;password&apos;).send_keys(self.account_str[1]) # 在自动输完密码之后记得点一下记住我 time.sleep(2) self.driver.find_element_by_xpath(&quot;./*//a[@class=&apos;btn_login&apos;]&quot;).click() # 拿手机扫二维码！ time.sleep(10) self.driver.get(&apos;https://mp.weixin.qq.com/&apos;) cookie_items = self.driver.get_cookies() for cookie_item in cookie_items: self.cookies[cookie_item[&apos;name&apos;]] = cookie_item[&apos;value&apos;] def get_token(self): url = &apos;https://mp.weixin.qq.com&apos; response = requests.get(url=url, cookies=self.cookies) self.token = re.findall(r&apos;token=(\\d+)&apos;, str(response.url))[0] def get_fakeid(self,query): query_id = &#123; &apos;action&apos;: &apos;search_biz&apos;, &apos;token&apos;: self.token, &apos;lang&apos;: &apos;zh_CN&apos;, &apos;f&apos;: &apos;json&apos;, &apos;ajax&apos;: &apos;1&apos;, &apos;random&apos;: random.random(), &apos;query&apos;: query, &apos;begin&apos;: &apos;0&apos;, &apos;count&apos;: &apos;5&apos;, &#125; search_url = &apos;https://mp.weixin.qq.com/cgi-bin/searchbiz?&apos; search_response = requests.get(search_url, cookies=self.cookies, headers=self.header, params=query_id) tmp_url = search_response.url # 构造结果url # print(tmp_url) lists = search_response.json().get(&apos;list&apos;)[0] # print(lists) fakeid = lists.get(&apos;fakeid&apos;) return fakeid def get_url(self): for query in self.wechat_official_accounts: count = 0 fakeid = self.get_fakeid(query) while True: query_id_data = &#123; &apos;token&apos;: self.token, &apos;lang&apos;: &apos;zh_CN&apos;, &apos;f&apos;: &apos;json&apos;, &apos;ajax&apos;: &apos;1&apos;, &apos;random&apos;: random.random(), &apos;action&apos;: &apos;list_ex&apos;, &apos;begin&apos;: count, &apos;count&apos;: &apos;10&apos;, &apos;query&apos;: self.query, &apos;fakeid&apos;: fakeid, &apos;type&apos;: &apos;9&apos; &#125; appmsg_url = &apos;https://mp.weixin.qq.com/cgi-bin/appmsg?&apos; appmsg_response = requests.get(appmsg_url, cookies=self.cookies, headers=self.header,params=query_id_data) tmp_appmsg_url = appmsg_response.url print(tmp_appmsg_url) appmsg_response_json = json.loads(appmsg_response.content) app_msg_cnt = appmsg_response_json[&apos;app_msg_cnt&apos;] print(appmsg_response_json) for msg_list in appmsg_response_json[&apos;app_msg_list&apos;]: print(msg_list[&apos;link&apos;]) self.article_url_list.append(msg_list[&apos;link&apos;]) if app_msg_cnt &lt;= 10 or app_msg_cnt - count &lt;= 10: break else: count += 10 print(self.article_url_list) print(len(self.article_url_list)) with open(&apos;article_url.txt&apos;, &apos;w&apos;) as file: for url in self.article_url_list: file.write(url) file.write(&apos;\\n&apos;)if __name__ == &apos;__main__&apos;: wechat_official_accounts = [&apos;公众号微信号&apos;] username = &apos;公众号账号&apos; password = &apos;公众号密码&apos; wechat_official = WechatArticleUrl(wechat_official_accounts,username,password) wechat_official.__main__() 参考来自：https://www.jianshu.com/p/adcc630336ae\u0010","tags":[{"name":"Python爬虫","slug":"Python爬虫","permalink":"http://yanjin.io/tags/Python爬虫/"}]},{"title":"如何写一篇永远保存在这个世界中的文章","date":"2018-04-26T03:41:18.000Z","path":"2018/04/26/foreverArticle/","text":"本文介绍了如何购买电子货币和区块链记录文章方法 目的最近我们身边发生了很多事情，比如说北大岳欣事件，比如说武汉理工大学研究生因为导师欺压跳楼事件等等。这里面经常发生的一件事情是，人们的发声被删除。比如说你写的公众号文章，或者是帖子，很容易就从网络上抹除了痕迹。 但直到前几天我看到了一篇文章，它介绍了区块链的一个应用,才有了一个比较完美的解决方法。我们可以利用区块链来记录我们的文章。 区块链 一句话，它是一种特殊的分布式数据库。 首先，区块链的主要作用是储存信息。任何需要保存的信息，都可以写入区块链，也可以从里面读取，所以它是数据库。 其次，任何人都可以架设服务器，加入区块链网络，成为一个节点。区块链的世界里面，没有中心节点，每个节点都是平等的，都保存着整个数据库。你可以向任何一个节点，写入/读取数据，因为所有节点最后都会同步，保证区块链一致。 区块链没有管理员，它是彻底无中心的。其他的数据库都有管理员，但是区块链没有。如果有人想对区块链添加审核，也实现不了，因为它的设计目标就是防止出现居于中心地位的管理当局。 正是因为无法管理，区块链才能做到无法被控制。否则一旦大公司大集团控制了管理权，他们就会控制整个平台，其他使用者就都必须听命于他们了。 引用来自：http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html 所以，我们利用区块链的不可删除性，来记录我们的文章。那么什么时候需要利用这个特性呢？那就是当你遇到了不公平的对待，需要在这个世界上，在网络发声的时候。当然，我们假设你所面对的不公是真实的，不是伪造的。 也许有的人在此时此刻说的谎话被人们当真了。可若你在区块链中记录了这一件事情，一百年后，事情的真相还是会水落石出。 区块链记录方法我自己是从某一个交易平台买了 100 RMB 以太坊币，然后从交易平台转账到我自己的钱包。至于要怎么买币，就留给大家去谷歌了。希望大家能够试一试这个探索的过程。因为直接得到的答案并不会深刻。但我就被坑了，从交易平台提现到钱包又要收手续费，把以太坊币换成人民币大概是 40+ RMB。 因此，首先你要有以太坊币，有了币之后你就可以发起转账了。而且买币之前你最好要有一个电子钱包，我用的是 imToken。 不过这个钱包不能自己给自己转账，我的方法就是安卓多开这个软件，创建了两个钱包，我就通过一个钱包转账给另外一个钱包。另外因为转账本身是需要给矿工手续费的，你把数据记录在区块链上，总要有人来处理吧。那就是矿工，矿工的收益除了自己挖到的币，还有就是这种交易费。 对于要记录的内容，英文内容可以直接转成 16 进制码，中文内容则要以 UTF-8 码的字符串形式转为 16 进制码。 转换网址：http://tool.haooyou.com/code?group=convert&amp;type=strToHex&amp;charset=UTF-8 所以我要先把自己这篇的文章以 UTF-8 码的字符串形式转为 16 进制码，最后还要在代码之前加上固定头部“0x”以表示 16 进制。 为了能够记录我们的文章，转账的时候要选择高级选项，这样我们才能把这个内容记录在区块链中。要记得千万不要把内容写在「备注」里面，要写在高级选项的十六进制数据中。 高级选项会让你自定义 Gas Price和 Gas Limit。 一笔转账需要花费矿工费 = Gas Price * Gas Limit。通常情况下，如果有人只说 Gas ，指的就是 Gas Limit，Gas Limitt 相当于汽车需要加多少汽油， Gas Price 相当于每升汽油的价格。 因为我这篇文章的字数接近 1500 字，所以这一次我输入的 Gas Limit 为 3000000，Gas Price 为 2 gwei。你必须包括足够的 gas 来支付计算资源，否则由于 Gas 不够报错 Out of gas。但最后我这个就没花完，所有未使用的 gas 在转账结束时退还了。 我试了一下，1500 左右的字矿工手续费大概需要人民币 7 块钱左右，也不贵。大家少喝两瓶饮料，就能让你的文章永远记录下来了。然后会得到最重要的 Hash 值，它是一长串数字字母。它是这个记录的凭据，你可以用各种方法把它记录下来。因为之后你可以在任何一个以太坊的节点中查询到你曾经记录过的信息。 以太坊查询网址：https://etherscan.io 在这里输入那串转账记录的 Hash 值，就可以看到你记录的文章啦。 后记我从过去这些事件得到最大的一个启发是，我们面前没有绝对的真相。你会发现呈现在你面前的数据都是别人想给你看到的。很多新闻，一开始是这个风向，说这个不好那个不好，某某的错。后来一研究，一推敲，发现很多地方是错的。 那么，上面的这种情况可能就要要求新闻工作者们有更高的追求。作为程序员，也要有自己的要求。我希望自己要有职业操守，和道德的修养。我们这一代最聪明的人，最顶尖的人，如果都去弄广告的算法，想着如何让人去点击广告，我个人觉得是一个很令人害怕的事情。 所以我希望能够做一些真正意义上有用的工具给大家，去改善我们的生活，去改变这个世界。 最后我把这文章记录在以太坊区块链上，如果有一天这个博客不在了，拿着那串 Hash 值还能看到我写下来的文字。 本文区块链查询地址 Hash：6ba91b389726c26116816bc5eba0d474c4a3f3af066078d294d36fe86c11dac5 参考方法和引用来自：http://www.wdk.pw/1410.html http://www.pingwest.com/how-to-post-blog-on-blockchain/","tags":[{"name":"区块链","slug":"区块链","permalink":"http://yanjin.io/tags/区块链/"}]}]