<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>YanJin&#39;s Blog</title>
  <icon>https://www.gravatar.com/avatar/4e7f4e9d900110ab9c32f0cbabd072cb</icon>
  <subtitle>每一个不曾起舞的日子都是对生命的辜负</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yanjin.io/"/>
  <updated>2019-03-23T13:44:02.759Z</updated>
  <id>http://yanjin.io/</id>
  
  <author>
    <name>Yan Jin</name>
    <email>yimjin@163.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>大四实习生拿到 Offer 备忘录</title>
    <link href="http://yanjin.io/2019/03/23/offer/"/>
    <id>http://yanjin.io/2019/03/23/offer/</id>
    <published>2019-03-23T12:02:17.000Z</published>
    <updated>2019-03-23T13:44:02.759Z</updated>
    
    <content type="html"><![CDATA[<p>以此作为未来找工作的提醒，切记切记，职场礼仪必备知识。<br><a id="more"></a></p><h2 id="情况"><a href="#情况" class="headerlink" title="情况"></a>情况</h2><p>大四的时候面试过好几家公司，拿到了实习生 Offer，然后有一些大公司都是会通过邮件给自己发 Offer，他们都有一个 Offer 在线确认链接，你可以选择接受 Offer。</p><h2 id="当时的处理方法"><a href="#当时的处理方法" class="headerlink" title="当时的处理方法"></a>当时的处理方法</h2><p>当时决定放弃入职，以为只要不点击 Offer 在线确认链接即可。但后来入职当天，忽然 HR 打电话问我怎么没来，我就知道我做错事情了。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="放弃-Offer-需即时联系-HR"><a href="#放弃-Offer-需即时联系-HR" class="headerlink" title="放弃 Offer 需即时联系 HR"></a>放弃 Offer 需即时联系 HR</h3><p>作为一个靠谱的人，下次决定放弃 Offer 的时候会先告诉 HR，系统有时候是不可信的。HR 可能以为你忘记点击确认链接了。</p><h3 id="做一个厚道的人"><a href="#做一个厚道的人" class="headerlink" title="做一个厚道的人"></a>做一个厚道的人</h3><p>放弃 Offer 是很正常的事情，但是应该知道职场礼仪，即时通知相关的人，不要太过于相信系统。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;以此作为未来找工作的提醒，切记切记，职场礼仪必备知识。&lt;br&gt;
    
    </summary>
    
    
      <category term="杂谈" scheme="http://yanjin.io/tags/%E6%9D%82%E8%B0%88/"/>
    
  </entry>
  
  <entry>
    <title>实习找 bug 杂谈</title>
    <link href="http://yanjin.io/2019/03/21/internthoughts/"/>
    <id>http://yanjin.io/2019/03/21/internthoughts/</id>
    <published>2019-03-21T12:02:17.000Z</published>
    <updated>2019-03-21T16:21:10.339Z</updated>
    
    <content type="html"><![CDATA[<p>纪念一下三个 bug 解决思路<br><a id="more"></a></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>利用 ansible 部署 mongoDB</p><h2 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h2><h3 id="对于代码读的不够多"><a href="#对于代码读的不够多" class="headerlink" title="对于代码读的不够多"></a>对于代码读的不够多</h3><p>同事写的ansible 脚本设置了默认拥有 mongo 账户，要有 sudo 权限，自己一直没仔细看脚本找到原因。</p><p>一直报错：权限不够</p><h3 id="mongoDB-安装程序版本"><a href="#mongoDB-安装程序版本" class="headerlink" title="mongoDB 安装程序版本"></a>mongoDB 安装程序版本</h3><p>当时使用的 Ubuntu 作为服务器，部署这个 mongoDB 的服务端一直提示错误。我将命令直接复制到远程机器进行测试，提示缺少某个共享库。</p><p>所以当时的思路就是直接百度，缺少这个共享库的报错如何解决。</p><p>但是百度了一圈感觉不太对，因为大家都认为是因为缺少安装了某个插件。</p><p>后来让同事过来看，原来是自己用的 mongoDB 安装程序版本没有对应上自己 Ubuntu 的版本，这样子也是会报错的。</p><h3 id="shell-脚本转义"><a href="#shell-脚本转义" class="headerlink" title="shell 脚本转义"></a>shell 脚本转义</h3><p>ansible 执行远程 shell 命令 kill 进程</p><p>因为 shell 脚本里面涉及到了一个 <strong>$</strong> 符号，脚本一直提示参数错误。</p><p>我当时的解决思路是，直接复制那句脚本到远程机器跑，没有任何问题。因此很纳闷，还以为又是没有 sudo 权限导致的错误</p><p>实际上是因为 shell 脚本需要对 <strong>$</strong> 符号进行转义，加一个 / 符号即可</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><h3 id="对数字要敏感"><a href="#对数字要敏感" class="headerlink" title="对数字要敏感"></a>对数字要敏感</h3><p>我当时确实看到了这个 mongoDB 安装程序脚本对不上，但是自己上官网寻找软件的时候，竟然没找到对应版本，迫不得己又下了一个别的版本。</p><p>新的版本因为也不是对应 Ubuntu 的，所以还是一样报错。</p><p>所以当时思路是对的，可惜没坚持下去。应该再仔细翻一下官网找到正确的安装包。</p><h3 id="不要问同事太傻的问题"><a href="#不要问同事太傻的问题" class="headerlink" title="不要问同事太傻的问题"></a>不要问同事太傻的问题</h3><p>个人认为上述两个问题都问同事解决有点傻。因为是自己的粗心大意导致的，记录下来就是要勉励自己，变得靠谱一点，不要浪费其他人的时间。</p><h3 id="实在解决不了才问同事"><a href="#实在解决不了才问同事" class="headerlink" title="实在解决不了才问同事"></a>实在解决不了才问同事</h3><p>因为一旦这个问题卡住太久了，时间就被浪费了。可能问同事五分钟，就可以等于你的一天。</p><p>比如说那个 shell 脚本转义的问题，我一直没找到解决的思路。但是如果你写过 shell 脚本或者踩的坑多了，你自然而然就知道如何解决。</p><h3 id="高手就是碰到过各种各样的坑"><a href="#高手就是碰到过各种各样的坑" class="headerlink" title="高手就是碰到过各种各样的坑"></a>高手就是碰到过各种各样的坑</h3><p>写的代码足够了，坑踩的足够多了，记录下来并总结，你也会成为高手。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;纪念一下三个 bug 解决思路&lt;br&gt;
    
    </summary>
    
    
      <category term="Python" scheme="http://yanjin.io/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>双网卡配置同时访问内网外网</title>
    <link href="http://yanjin.io/2019/03/03/networkcard/"/>
    <id>http://yanjin.io/2019/03/03/networkcard/</id>
    <published>2019-03-02T16:02:17.000Z</published>
    <updated>2019-03-02T16:18:48.609Z</updated>
    
    <content type="html"><![CDATA[<p>这个方案适用于内网，自己可以买一个无线网卡，连接自己的 Wi-Fi 热点实现外网的访问。<br><a id="more"></a></p><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>1.无线网卡（免驱动版本：即插入后自带驱动自行安装）</p><p>2.流量较多的手机卡可以 Wi-Fi 热点</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>Win10</li><li>TP-LINK TL-WN726N 免驱版 USB 无线网卡</li></ul><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><ul><li>网关</li></ul><p>在计算机网络中，网关（英语：Gateway）是转发其他服务器通信数据的服务器，接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理。有时客户端可能都不会察觉，自己的通信目标是一个网关。</p><p>简单的理解来看，网关就是一个网络连接到另一个网络的“关口”。</p><p>默认网关是指不管流量去往哪里，如果没有指定去向，那么流量就会被引入默认网关指向的 IP。而我们现在有两块网卡都设置了默认网关(可能是你自己设置的，也可能是 DHCP 分配的)，并且他们的指向是不同的，这就导致流量不知道到底去往哪个默认网关，结果就是所有网站都无法正常访问。</p><ul><li>子网掩码</li></ul><p>子网掩码 <em>(subnet mask)</em> 又叫网络掩码、地址掩码、子网络遮罩，是一个应用于 <em>TCP/IP</em> 网络的 <em>32</em> 位二进制值。它可以屏蔽掉 <em>IP</em> 地址中的一部分，从而分离出 <em>IP</em> 地址中的网络部分与主机部分，基于子网掩码，管理员可以将网络进一步划分为若干子网。它必须结合 <em>IP</em> 地址一起使用。</p><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-安装网卡驱动"><a href="#1-安装网卡驱动" class="headerlink" title="1.安装网卡驱动"></a>1.安装网卡驱动</h3><p>插入网卡后，点击对应的 U 盘，里面自带驱动程序。</p><h3 id="2-查看内网配置"><a href="#2-查看内网配置" class="headerlink" title="2.查看内网配置"></a>2.查看内网配置</h3><p>目的是为了获取公司内网的网关，和自己的内网 IP 地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipconfig /all</span><br></pre></td></tr></table></figure><h3 id="3-添加内网路由策略"><a href="#3-添加内网路由策略" class="headerlink" title="3.添加内网路由策略"></a>3.添加内网路由策略</h3><p>例如通过第二步可以看到自己的内网 IP 地址是 10 开头的，那么我们就把这一整个 10 开头的网段设置为内网的网关。</p><p>打开 CMD，输入以下这段静态路由命令。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">route -p add 10.0.0.0 mask 255.0.0.0 10.0.0.254</span><br></pre></td></tr></table></figure><p>-p 是指永久添加到路由表；第一个 IP 段是你的内网网段；第二个是子网掩码，3 类私有地址段情况不同；第三个 IP 地址是你内网的默认网关。</p><p>另外两类内网地址的静态路由命令可供参考<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">route -p add 192.168.0.0 mask 255.255.255.0 192.168.0.1</span><br><span class="line">route -p add 172.16.0.0 mask 255.255.0.0 172.16.0.254</span><br></pre></td></tr></table></figure></p><h3 id="4-设置外网流量优先"><a href="#4-设置外网流量优先" class="headerlink" title="4.设置外网流量优先"></a>4.设置外网流量优先</h3><p>请通过 Win10 桌面右下角的网络设置，进入设置页面。选择显示所有可用的网络，打开外网网卡的 IPV4 设置，选择”高级”，去掉”自动跃点”，手工填写跃点数为”1”，保存退出。</p><p>这里的跃点数是越小，优先级越高。</p><h3 id="5-测试"><a href="#5-测试" class="headerlink" title="5.测试"></a>5.测试</h3><p>首先可以通过进入一些可以查询自己 IP 地址的网站看看自己是不是手机流量的 IP，再随便测试一下内网的页面访问能否正常即可。</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="http://www.slyar.com/blog/route-interior-exterior-network.html" target="_blank" rel="noopener">ROUTE命令配置路由策略使双网卡可以同时访问内网和外网</a><br><a href="https://blog.csdn.net/jason314/article/details/5447743" target="_blank" rel="noopener">子网掩码详解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这个方案适用于内网，自己可以买一个无线网卡，连接自己的 Wi-Fi 热点实现外网的访问。&lt;br&gt;
    
    </summary>
    
    
      <category term="网络" scheme="http://yanjin.io/tags/%E7%BD%91%E7%BB%9C/"/>
    
  </entry>
  
  <entry>
    <title>搭建属于自己的Google-反向代理Google</title>
    <link href="http://yanjin.io/2019/02/07/yourgoogle/"/>
    <id>http://yanjin.io/2019/02/07/yourgoogle/</id>
    <published>2019-02-07T12:02:17.000Z</published>
    <updated>2019-02-07T16:10:27.515Z</updated>
    
    <content type="html"><![CDATA[<p>公司里面用不了 VPN，不能科学上网？那不如搭建一个自己专用的 Google 网站，不翻墙也可以科学搜索了！<br><a id="more"></a></p><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>公司网络有限制，VPN 设置了之后也连接不上服务器。自己又没有公司内网里面海外服务器，幸亏看到这个反向代理 Google 方法了，简直拯救了我！</p><h2 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h2><p>1.海外 VPS 一台（实测：DigitalOcean）</p><p>2.域名一个</p><p>推荐 Vultr 和 DigitalOcean，DigitalOcean有学生优惠，利用 Github 的学生包（有学生邮箱注册即可）可以免费获得 DigitalOcean 60 刀，可以免费用一年 5 刀每月的服务器。</p><p>DigitalOcean：<br><a href="https://m.do.co/c/962c44fae7c8" target="_blank" rel="noopener">注册链接</a><br>通过我的链接注册可以直接获得 10 刀！付款方法支持 Paypal，只需要绑定一张银行卡就可以付款<br>优势：<br>一旦 IP 被墙，备份一下服务器，删除服务器，重新创建一个即可获得新的IP</p><p>Vultr：<br><a href="https://www.vultr.com/?ref=7820045" target="_blank" rel="noopener">注册链接</a><br>Vultr 按小时计费，可以自己换 IP，最低 3.5 美元/月，新用户注册就送 30 美元（有限期一个月），分享到 Twitter 再赠送 3 美元，支持支付宝和微信支付，非常适合新手用户</p><h2 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h2><ul><li>1 GB Memory  / 25 GB Disk  / SFO2</li><li>CentOS 7.5 x64</li><li>确保是干净的操作系统，没有安装过其它环境带的Apache/Nginx/php/MySQL</li></ul><h2 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h2><h3 id="1-一键安装宝塔"><a href="#1-一键安装宝塔" class="headerlink" title="1.一键安装宝塔"></a>1.一键安装宝塔</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y wget &amp;&amp; wget -O install.sh http://download.bt.cn/install/install.sh &amp;&amp; sh install.sh</span><br></pre></td></tr></table></figure><h3 id="2-宝塔安装-LNMP-环境"><a href="#2-宝塔安装-LNMP-环境" class="headerlink" title="2.宝塔安装 LNMP 环境"></a>2.宝塔安装 LNMP 环境</h3><p>成功安装宝塔之后，会显示一个URL，账号和密码，这个是进入宝塔界面的方法。<br>进入首页之后，他会自动跳出来安装环境，我们选择安装 LNMP 环境，FTP的可以不用勾选，选择极速安装即可</p><h3 id="3-域名解析服务器-IP"><a href="#3-域名解析服务器-IP" class="headerlink" title="3.域名解析服务器 IP"></a>3.域名解析服务器 IP</h3><p>在使用反向代理之前必须要把 A 记录解析到需要反代的服务器 IP 地址。<br>这一步进入到自己的域名服务商那里添加解析记录。</p><h3 id="4-新建站点"><a href="#4-新建站点" class="headerlink" title="4.新建站点"></a>4.新建站点</h3><p>宝塔控制面板首页-网站-添加站点<br>域名添加自己的域名，点击提交</p><h3 id="5-反向代理设置"><a href="#5-反向代理设置" class="headerlink" title="5.反向代理设置"></a>5.反向代理设置</h3><p>在站点的页面，选择设置，选择反向代理<br>目标URL设置为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://www.google.com.hk</span><br></pre></td></tr></table></figure><p>发送域名设置为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">www.google.com.hk</span><br></pre></td></tr></table></figure></p><p>最后点击保存</p><h3 id="6-添加-SSL-证书"><a href="#6-添加-SSL-证书" class="headerlink" title="6.添加 SSL 证书"></a>6.添加 SSL 证书</h3><p>目的是增加自己这个镜像网站被墙的难度。<br><a href="https://freessl.cn/" target="_blank" rel="noopener">在线申请免费 SSL 证书</a>，在这里申请一个免费证书<br>在站点的页面，选择设置，选择 SSL - 其他证书<br>将下载的 private.key 文件中的值添加到密钥，full_chain.pem 文件中的值添加到证书，保存！<br>设置强制 HTTPS，这样子访问 HTTP 网址后也会自动跳转到HTTPS页面</p><h3 id="7-重启网站"><a href="#7-重启网站" class="headerlink" title="7.重启网站"></a>7.重启网站</h3><p>网站-状态-关闭-开启，即成功重启。<br>最后输入自己的域名测试</p><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://www.fengweishang.com/baota-nginx-reverse-proxy.html" target="_blank" rel="noopener">宝塔面板nginx反向代理教程</a><br><a href="https://www.bbaaz.com/thread-88-1-1.html" target="_blank" rel="noopener">Linux安装宝塔面板一键反向代理谷歌</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司里面用不了 VPN，不能科学上网？那不如搭建一个自己专用的 Google 网站，不翻墙也可以科学搜索了！&lt;br&gt;
    
    </summary>
    
    
      <category term="VPS" scheme="http://yanjin.io/tags/VPS/"/>
    
  </entry>
  
  <entry>
    <title>Django REST framework 利用 Token 实现登陆API</title>
    <link href="http://yanjin.io/2019/01/24/djangoToken/"/>
    <id>http://yanjin.io/2019/01/24/djangoToken/</id>
    <published>2019-01-24T12:02:17.000Z</published>
    <updated>2019-01-24T13:58:10.704Z</updated>
    
    <content type="html"><![CDATA[<p>本文优化了 Django REST framework 的 Token 模块，实现登陆即更新一次 Token，修复了 Django Token 千年不变的问题，并且实现了先从缓存中获取 Token，如果没有再从数据库中取出来的缓存机制。<br><a id="more"></a></p><h2 id="版本说明"><a href="#版本说明" class="headerlink" title="版本说明"></a>版本说明</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Python3</span><br><span class="line">Django==2.0</span><br><span class="line">rest_framework==3.9</span><br></pre></td></tr></table></figure><h2 id="Django-后端设置"><a href="#Django-后端设置" class="headerlink" title="Django 后端设置"></a>Django 后端设置</h2><h3 id="settings-py"><a href="#settings-py" class="headerlink" title="settings.py"></a>settings.py</h3><p>假如 Django 工程名为 platform，那么项目根目录下会有一个 platform 文件夹，首先需要修改工程的配置文件settings.py文件，在 INSTALLED_APPS 中添加了两个模块，rest_framework 和 rest_framework.authtoken。还增加了 REST_FRAMEWORK 的配置内容。</p><p>里面有三个属性，可以从英文名看出来是什么意思。DEFAULT_AUTHENTICATION_CLASSES 指的是默认认证类，即确定你是谁。代码里面添加了两个类，第一个表示的是BasicAuthentication认证方式，即传统的账号密码登陆。第二个是自己重写了继承 rest_framework.authentication.BaseAuthentication 这个类的内容，在这个 ExpiringTokenAuthentication 类中实现从缓存中获取 Token，如果没有再从数据库中取出来。</p><p>DEFAULT_PERMISSION_CLASSES 指的是默认访问权限，在确定了你是谁之后，还要确定一下你的权限，即你能干什么，官方名字叫做鉴权。这里设置了所有 API 的默认权限都必须是认证之后才可以访问。</p><p>DEFAULT_RENDERER_CLASSES 指的是默认返回类型，设置为 rest_framework.renderers.JSONRenderer 的目的是只返回 JSON 格式，之前框架自带的 API 页面就没有了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">INSTALLED_APPS = [ </span><br><span class="line">    <span class="string">'django.contrib.admin'</span>,</span><br><span class="line">    <span class="string">'django.contrib.auth'</span>,</span><br><span class="line">    <span class="string">'django.contrib.contenttypes'</span>,</span><br><span class="line">    <span class="string">'django.contrib.sessions'</span>,</span><br><span class="line">    <span class="string">'django.contrib.messages'</span>,</span><br><span class="line">    <span class="string">'django.contrib.staticfiles'</span>,</span><br><span class="line">    <span class="string">'rest_framework'</span>,</span><br><span class="line">    <span class="string">'rest_framework.authtoken'</span>,</span><br><span class="line">    <span class="string">'account'</span></span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">REST_FRAMEWORK = &#123;</span><br><span class="line">    <span class="string">'DEFAULT_AUTHENTICATION_CLASSES'</span>: [</span><br><span class="line">        <span class="string">'rest_framework.authentication.BasicAuthentication'</span>,</span><br><span class="line">        <span class="string">'account.auth.ExpiringTokenAuthentication'</span>,</span><br><span class="line">        <span class="comment">#'rest_framework.authentication.TokenAuthentication',</span></span><br><span class="line">    ],</span><br><span class="line">    <span class="string">"DEFAULT_PERMISSION_CLASSES"</span>: [</span><br><span class="line">        <span class="string">"rest_framework.permissions.IsAuthenticated"</span>,</span><br><span class="line">    ],</span><br><span class="line">    <span class="string">'DEFAULT_RENDERER_CLASSES'</span>: (</span><br><span class="line">        <span class="string">'rest_framework.renderers.JSONRenderer'</span>,</span><br><span class="line">    )</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="auth-py"><a href="#auth-py" class="headerlink" title="auth.py"></a>auth.py</h3><p>下面是 ExpiringTokenAuthentication 这个类的具体实现代码，代码经测试可运行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">\account\auth.py</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> pytz</span><br><span class="line"><span class="keyword">from</span> django.utils.translation <span class="keyword">import</span> ugettext_lazy <span class="keyword">as</span> _</span><br><span class="line"><span class="keyword">from</span> django.core.cache <span class="keyword">import</span> cache</span><br><span class="line"><span class="keyword">import</span> datetime</span><br><span class="line"><span class="keyword">from</span> rest_framework.authentication <span class="keyword">import</span> BaseAuthentication</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> exceptions</span><br><span class="line"><span class="keyword">from</span> rest_framework.authtoken.models <span class="keyword">import</span> Token</span><br><span class="line"><span class="keyword">from</span> rest_framework <span class="keyword">import</span> HTTP_HEADER_ENCODING</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取请求头里的 token 信息</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_authorization_header</span><span class="params">(request)</span>:</span></span><br><span class="line">    <span class="string">"""</span></span><br><span class="line"><span class="string">    Return request's 'Authorization:' header, as a bytestring.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    Hide some test client ickyness where the header can be unicode.</span></span><br><span class="line"><span class="string">    """</span></span><br><span class="line">    auth = request.META.get(<span class="string">'HTTP_AUTHORIZATION'</span>, <span class="string">b''</span>)</span><br><span class="line">    <span class="keyword">if</span> isinstance(auth, type(<span class="string">''</span>)):</span><br><span class="line">        <span class="comment"># Work around django test client oddness</span></span><br><span class="line">        auth = auth.encode(HTTP_HEADER_ENCODING)</span><br><span class="line">    <span class="keyword">return</span> auth</span><br><span class="line"></span><br><span class="line"><span class="comment"># 自定义的 ExpiringTokenAuthentication 认证方式</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ExpiringTokenAuthentication</span><span class="params">(BaseAuthentication)</span>:</span></span><br><span class="line">    model = Token</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        auth = get_authorization_header(request)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> auth:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">None</span></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            token = auth.decode()</span><br><span class="line">        <span class="keyword">except</span> UnicodeError:</span><br><span class="line">            msg = _(<span class="string">'Invalid token header. Token string should not contain invalid characters.'</span>)</span><br><span class="line">            <span class="keyword">raise</span> exceptions.AuthenticationFailed(msg)</span><br><span class="line">        <span class="keyword">return</span> self.authenticate_credentials(token)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate_credentials</span><span class="params">(self, key)</span>:</span></span><br><span class="line">        <span class="comment"># 增加了缓存机制</span></span><br><span class="line">      <span class="comment"># 首先先从缓存中查找</span></span><br><span class="line">        token_cache = <span class="string">'token_'</span> + key</span><br><span class="line">        cache_user = cache.get(token_cache)</span><br><span class="line">        <span class="comment">#print(cache)</span></span><br><span class="line">        <span class="keyword">if</span> cache_user:</span><br><span class="line">            print(<span class="string">'cache token get!'</span>)</span><br><span class="line">            <span class="keyword">return</span> (cache_user.user, cache_user)  <span class="comment"># 首先查看 token 是否在缓存中，若存在，直接返回用户</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">            token = self.model.objects.get(key=key[<span class="number">6</span>:])</span><br><span class="line"></span><br><span class="line">        <span class="keyword">except</span> self.model.DoesNotExist:</span><br><span class="line">            <span class="keyword">raise</span> exceptions.AuthenticationFailed(<span class="string">'Invalid request'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> token.user.is_active:</span><br><span class="line">            <span class="keyword">raise</span> exceptions.AuthenticationFailed(<span class="string">'Invalid user'</span>)</span><br><span class="line"></span><br><span class="line">        utc_now = datetime.datetime.utcnow()</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (utc_now.replace(tzinfo=pytz.timezone(<span class="string">"UTC"</span>)) - token.created.replace(tzinfo=pytz.timezone(<span class="string">"UTC"</span>))).days &gt; <span class="number">1</span>:  <span class="comment"># 设定存活时间 1 天</span></span><br><span class="line">            <span class="keyword">raise</span> exceptions.AuthenticationFailed(<span class="string">'Invalid token'</span>)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> token:</span><br><span class="line">            token_cache = <span class="string">'token_'</span> + key</span><br><span class="line">            cache.set(token_cache, token, <span class="number">24</span> * <span class="number">1</span> * <span class="number">60</span> * <span class="number">60</span>)  <span class="comment"># 添加 token_xxx 到缓存，缓存保存时间为 1 天</span></span><br><span class="line">        <span class="keyword">return</span> (token.user, token)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">authenticate_header</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Token'</span></span><br></pre></td></tr></table></figure></p><p>从上面这个代码可以看出来，我们后端所有的 API 请求，都会从请求的 Headers 中取出来 AUTHORIZATION 字段</p><h3 id="登陆函数"><a href="#登陆函数" class="headerlink" title="登陆函数"></a>登陆函数</h3><p>代码中加有注释，很好理解，主要工作就是通过 user 拿到 Token，然后删除 Token，再重新创建它。可以看到登陆函数加了 permission_classes 和 authentication_classes，设置为空就是为了覆盖之前的默认设置，所有人不需要 Token 值也可以访问这个登陆 API。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> rest_framework.views <span class="keyword">import</span> APIView</span><br><span class="line"><span class="keyword">from</span> rest_framework.authtoken.models <span class="keyword">import</span> Token</span><br><span class="line"><span class="keyword">from</span> django.contrib.auth <span class="keyword">import</span> authenticate</span><br><span class="line"><span class="keyword">import</span> json</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoginView</span><span class="params">(APIView)</span>:</span></span><br><span class="line"></span><br><span class="line">    permission_classes = []</span><br><span class="line">    authentication_classes = []</span><br><span class="line"></span><br><span class="line">   </span><br><span class="line"><span class="meta">    @get_request_args</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">post</span><span class="params">(self, request, args)</span>:</span></span><br><span class="line">        print(args)</span><br><span class="line">        username = args.get(<span class="string">"username"</span>)</span><br><span class="line">        password = args.get(<span class="string">"password"</span>)</span><br><span class="line">        print(username)</span><br><span class="line">        print(password)</span><br><span class="line">        user = authenticate(username=username, password=password)</span><br><span class="line">        <span class="keyword">if</span> user <span class="keyword">is</span> <span class="keyword">not</span> <span class="keyword">None</span> <span class="keyword">and</span> user.is_active:</span><br><span class="line">            <span class="comment"># 更新token值</span></span><br><span class="line">            token = Token.objects.get(user=user)</span><br><span class="line">            token.delete()</span><br><span class="line">            token = Token.objects.create(user=user)</span><br><span class="line"></span><br><span class="line">            success_content = &#123;</span><br><span class="line">                <span class="string">"token"</span>: token.key,</span><br><span class="line">            &#125;</span><br><span class="line">            test = json.dumps(success_content)</span><br><span class="line">            <span class="comment">#return JsonResponse(success_content, status=status.HTTP_200_OK)</span></span><br><span class="line">            <span class="keyword">return</span> Response(success_content, status=status.HTTP_200_OK)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            error_content = &#123;</span><br><span class="line">                <span class="string">"detail"</span>: <span class="string">'Invalid username or password'</span>,</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> Response(error_content, status=status.HTTP_401_UNAUTHORIZED)</span><br><span class="line">        </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_request_args</span><span class="params">(func)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_get_request_args</span><span class="params">(self, request)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> request.method == <span class="string">'GET'</span>:</span><br><span class="line">            args = request.GET</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            body = request.body</span><br><span class="line">            <span class="keyword">if</span> body:</span><br><span class="line">                <span class="keyword">try</span>:</span><br><span class="line">                    args = json.loads(body)</span><br><span class="line">                <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">                    print(e)</span><br><span class="line">                    <span class="comment"># return makeJsonResponse(status=StatusCode.EXECUTE_FAIL, message=str(e))</span></span><br><span class="line">                    args = request.POST</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                args = request.POST</span><br><span class="line">        <span class="keyword">return</span> func(self, request, args)</span><br><span class="line">    <span class="keyword">return</span> _get_request_args</span><br></pre></td></tr></table></figure><h3 id="urls-py"><a href="#urls-py" class="headerlink" title="urls.py"></a>urls.py</h3><p>利用 Django REST framework 的 APIView 生成对应的API</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> account <span class="keyword">import</span> api</span><br><span class="line"></span><br><span class="line">urlpatterns = [</span><br><span class="line">    url(<span class="string">'login-demo/'</span>, api.LoginView.as_view()),</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h2 id="前端请求格式"><a href="#前端请求格式" class="headerlink" title="前端请求格式"></a>前端请求格式</h2><p>我们前端所有的 API 请求，都需要在请求的 Headers 中添加 AUTHORIZATION 字段，AUTHORIZATION 的值为 Token 加一个空格，再加上真正的 Token 值。<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AUTHORIZATION:Token 8ba11785d9700b7bc1a311428e6c3a3fe16e9145</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文优化了 Django REST framework 的 Token 模块，实现登陆即更新一次 Token，修复了 Django Token 千年不变的问题，并且实现了先从缓存中获取 Token，如果没有再从数据库中取出来的缓存机制。&lt;br&gt;
    
    </summary>
    
    
      <category term="Django" scheme="http://yanjin.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>Django 执行原始 SQL 语句参数化查询-预防 SQL 注入</title>
    <link href="http://yanjin.io/2019/01/21/performingRawSQLqueries/"/>
    <id>http://yanjin.io/2019/01/21/performingRawSQLqueries/</id>
    <published>2019-01-21T12:02:17.000Z</published>
    <updated>2019-01-21T12:02:58.034Z</updated>
    
    <content type="html"><![CDATA[<p>Django 原始 SQL 语句参数化查询，包括 like 模糊查询<br><a id="more"></a></p><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>实习内容：开发一个数据库运维系统</p><p>需求：因为我们操作的是远程的数据库，包括Oracle、MySQL、MongoDB，有大量的查询语句需要直接用到raw SQL语句，这里不适合Django的模型 ORM 操作</p><p>后端语言：Python3</p><p>框架：Django2.0 &amp; Django REST framework</p><h2 id="实践"><a href="#实践" class="headerlink" title="实践"></a>实践</h2><h3 id="1-创建-SQL-文件"><a href="#1-创建-SQL-文件" class="headerlink" title="1.创建 SQL 文件"></a>1.创建 SQL 文件</h3><p>我们以Table 搜素为例，首先是创建一个 SQL 文件，我们通过直接调用文件中的 SQL 语句增加代码整洁性。比如说，对于 Oracle 下的所有 SQL 文件我都会放在一个文件夹中。</p><p>需要搜素的参数值我们设置为 %s，如下面的代码所示，</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT OWNER,TABLE_NAME,TABLESPACE_NAME,STATUS,LOGGING,NUM_ROWS,BLOCKS,DEGREE,LAST_ANALYZED,TEMPORARY <span class="keyword">from</span> dba_tables WHERE owner like %s And table_name like %s order by OWNER,TABLE_NAME asc</span><br><span class="line">^EOF</span><br></pre></td></tr></table></figure><p>如果SQL 语句此时里面有需要用到的百分号,需要双写百分号，如下面的代码所示</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT foo FROM bar WHERE baz = <span class="string">'30%%'</span> AND id = %s</span><br></pre></td></tr></table></figure><h3 id="2-读取-SQL-文件"><a href="#2-读取-SQL-文件" class="headerlink" title="2.读取 SQL 文件"></a>2.读取 SQL 文件</h3><p>split()：用于拆分字符串。通过指定分隔符对字符串进行切片，并返回分割后的字符串列表（list）。 </p><p>strip()：用于移除字符串头尾指定的字符（默认为空格或换行符）或字符序列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_sql</span><span class="params">(sql_file)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> open(sql_file, <span class="string">'r'</span>) <span class="keyword">as</span> fr:</span><br><span class="line">        sql = fr.read().split(<span class="string">'^EOF'</span>)[<span class="number">0</span>].strip()</span><br><span class="line">    <span class="keyword">return</span> sql</span><br><span class="line">    </span><br><span class="line">sql_file = <span class="string">"oracle/sql/index_parameters_sessions_detail_search.sql"</span></span><br><span class="line">sql = get_sql(sql_file)</span><br></pre></td></tr></table></figure><h3 id="3-参数赋值"><a href="#3-参数赋值" class="headerlink" title="3.参数赋值"></a>3.参数赋值</h3><p>like 模糊参数需要将搜素的参数设置格式为 %test%，test修改为我们搜素的值噢</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">params = [<span class="string">"%&#123;&#125;%"</span>.format(owner.upper()), <span class="string">"%&#123;&#125;%"</span>.format(table_name.upper())]</span><br></pre></td></tr></table></figure><p>如果不是like 查询,我们的参数的形式为 list 即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">params = [username]</span><br></pre></td></tr></table></figure><h3 id="4-执行-SQL"><a href="#4-执行-SQL" class="headerlink" title="4.执行 SQL"></a>4.执行 SQL</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cur.execute(sql, params)</span><br></pre></td></tr></table></figure><h2 id="官方样例代码"><a href="#官方样例代码" class="headerlink" title="官方样例代码"></a>官方样例代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> django.db <span class="keyword">import</span> connection</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_custom_sql</span><span class="params">(self)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> connection.cursor() <span class="keyword">as</span> cursor:</span><br><span class="line">        cursor.execute(<span class="string">"UPDATE bar SET foo = 1 WHERE baz = %s"</span>, [self.baz])</span><br><span class="line">        cursor.execute(<span class="string">"SELECT foo FROM bar WHERE baz = %s"</span>, [self.baz])</span><br><span class="line">        row = cursor.fetchone()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> row</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://docs.djangoproject.com/en/2.1/topics/db/sql/#executing-custom-sql-directly" target="_blank" rel="noopener">Django 文档</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Django 原始 SQL 语句参数化查询，包括 like 模糊查询&lt;br&gt;
    
    </summary>
    
    
      <category term="Django" scheme="http://yanjin.io/tags/Django/"/>
    
  </entry>
  
  <entry>
    <title>hexo-theme-indigo 博客评论系统 Valine 配置</title>
    <link href="http://yanjin.io/2019/01/20/blogValine/"/>
    <id>http://yanjin.io/2019/01/20/blogValine/</id>
    <published>2019-01-20T12:02:17.000Z</published>
    <updated>2019-01-24T11:06:06.539Z</updated>
    
    <content type="html"><![CDATA[<p>适用于想更换主题为 hexo-theme-indigo 的朋友，本篇文章可以带你如何正确的配置 hexo-theme-indigo 的评论系统Valine<br><a id="more"></a></p><h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>花费了一个下午和晚上折腾博客，因为之前用的主题 Next 行间隔太大了，字体又小小的，自己看的不是很舒服，就想换一个主题，所以换成了 hexo-theme-indigo 这个主题。</p><p>折腾过程中官网没有给出配置博客评论系统的代码，我用之前主题 Next的 Valine配置怎么都显示不出来，最后搜索到一篇文章终于发现了不同的地方，hexo-theme-indigo里面的配置中是 appId，不是 appid。</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>修改博客对应的主题目录的配置文件，例如blog/themes/indigo/_config.yml，直接添加下方代码即可，修改对应的 id 和 key 值为自己 Leancloud 的。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">valine:</span><br><span class="line">  enable: true # 如果你想使用valine，请将值设置为 true</span><br><span class="line">  appId:  # your leancloud appId</span><br><span class="line">  appKey:  # your leancloud appKey</span><br><span class="line">  notify: true # Mail notify</span><br><span class="line">  verify: false # Verify code</span><br><span class="line">  avatar: mm # Gravatar style : mm/identicon/monsterid/wavatar/retro/hide</span><br><span class="line">  placeholder: Just go go # Comment Box placeholder</span><br><span class="line">  guest_info: nick,mail # Comment header info</span><br><span class="line">  pageSize: 10 # comment list page size</span><br></pre></td></tr></table></figure><h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><p><a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank" rel="noopener">hexo-theme-indigo</a><br><a href="https://valine.js.org/" target="_blank" rel="noopener">Valine</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;适用于想更换主题为 hexo-theme-indigo 的朋友，本篇文章可以带你如何正确的配置 hexo-theme-indigo 的评论系统Valine&lt;br&gt;
    
    </summary>
    
    
      <category term="Hexo" scheme="http://yanjin.io/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>威胁猎人初级安全实习生面经</title>
    <link href="http://yanjin.io/2018/11/15/interviewThreadHunter/"/>
    <id>http://yanjin.io/2018/11/15/interviewThreadHunter/</id>
    <published>2018-11-15T01:42:58.897Z</published>
    <updated>2019-01-20T11:55:29.081Z</updated>
    
    <content type="html"><![CDATA[<p>公司在深圳，办公环境很好，前台小姐姐很漂亮，有程序猿鼓励师猫猫一只，方向我也很喜欢，打击黑灰产。<br><a id="more"></a></p><h2 id="面试时间及岗位"><a href="#面试时间及岗位" class="headerlink" title="面试时间及岗位"></a>面试时间及岗位</h2><p>时间：2018 年 11 月 9 日 下午 4 点</p><p>岗位：威胁猎人初级安全实习生</p><h2 id="技术官一面"><a href="#技术官一面" class="headerlink" title="技术官一面"></a>技术官一面</h2><p>技术官主要是看了我的简历，开始说道他也是通信工程毕业的，知道我们电子信息科学与技术学什么，知道我们学的很杂哈哈。</p><p>然后问了我下面几个问题：</p><p>1.OSI 七层模型是哪七层？（没答出来全部，记得一两个）</p><p>2.有没有用过 Linux 系统</p><p>3.Cat 命令和 Grep 命令的使用方法，比如说考了我如何匹配搜索两个 TXT，一个 TXT 文本里面有很多 ip 地址，另外一个 TXT 文本里面包含了很多黑产的监控流量有 ip 地址，发送数据包之类的</p><p>4.是否了解黑产和灰产，让我说说自己知道的</p><p>我回答了猫池，还有物联网 IOT 的肉鸡 DDOS 攻击，打码平台，薅羊毛党啊等等</p><p>然后技术官就跟我介绍了他们这个部门主要做啥</p><h2 id="CTO二面"><a href="#CTO二面" class="headerlink" title="CTO二面"></a>CTO二面</h2><p>当时大佬一进来我就震惊了，我以为一面就可以了，我只是面一个实习生咋还跑出来大佬呢</p><p>1.什么时候开始学安全的（我回答今年年初）</p><p>2.设计一个登陆注册的系统有什么要考虑的地方</p><p>要有验证码功能，而且最好用现在比较难以破解的验证码，比如 Google 和网易的验证码。</p><p>密码也应该有强度要求，然后不能直接明文发生登陆或者注册请求到服务器，要加盐加密传输，数据库存储也应该是加盐加密保存，防止被脱裤之后明文裸奔</p><p>参数还要带有 csfr_token 值防止 CSRF 攻击</p><p>cookie 中要设置 HttpOnly 属性，那么通过 js 脚本将无法读取到 cookie 信息，这样能有效的防止 XSS 攻击</p><p>对于参数的输入要进行参数化参训防止SQL注入</p><p>3.https 能不能被破解</p><p>我说可以，就是在客户端或者服务器端劫持，替换了证明就可以看到 https 明文传输的内容。但是 CTO 指出来这是因为你用了抓包工具，而且还是在网站没有校验证书的情况下，如果校验的话中间人劫持也没用</p><p>4.我简历上学校正方的漏洞是怎么挖到的</p><p>5.自己还有投别的公司拿到 offer 吗？（我说还投了一家教育公司，他就有点怀疑我是不是真的喜欢安全了，这里建议不要回答不相关的）</p><p>6.问我如果数据库被脱裤了，有什么处理方案</p><p>一赶紧溯源攻击，找到入侵者，然后寻找是否这个数据库是否在网上公开，要即可减少被售卖或者公开的机会</p><p>二是告诉用户，提醒用户改密码</p><p>面试的时候，大佬眉头一直紧皱的看着我的简历，让我很害怕</p><h2 id="HR面"><a href="#HR面" class="headerlink" title="HR面"></a>HR面</h2><p>HR面就没问啥了，问我期望薪水。我说 4k-5k 然后似乎被嘲笑了哈哈，说实习生工资没有这么高的，进来主要是学东西。</p><p>还问我几时可以到岗，最后是拿到这个实习生 offer 啦！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;公司在深圳，办公环境很好，前台小姐姐很漂亮，有程序猿鼓励师猫猫一只，方向我也很喜欢，打击黑灰产。&lt;br&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://yanjin.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>360企业安全实习生面经</title>
    <link href="http://yanjin.io/2018/11/15/interview360/"/>
    <id>http://yanjin.io/2018/11/15/interview360/</id>
    <published>2018-11-15T01:42:58.897Z</published>
    <updated>2019-01-20T11:51:28.761Z</updated>
    
    <content type="html"><![CDATA[<p>360企业安全-福建分公司安全实习生面试经验<br><a id="more"></a></p><h2 id="面试时间及岗位"><a href="#面试时间及岗位" class="headerlink" title="面试时间及岗位"></a>面试时间及岗位</h2><p>时间：2018 年 11 月 17 日 下午 4 点</p><p>岗位：360企业安全实习生</p><h2 id="技术官面"><a href="#技术官面" class="headerlink" title="技术官面"></a>技术官面</h2><p>1.是否还有课，论文什么时候答辩</p><p>2.看我比较擅长 Python，问我有没有搭过什么系统</p><p>搭过公众号开发的一个查询功能</p><p>3.有没有写过爬虫或者什么漏洞利用工具（ EXP 和 POC ）</p><p>写过 Python 爬虫，抢课代码，没写过 EXP 和 POC </p><p>4.Linux 进程如何查看？</p><p>我回答 ps -a,但是应该回答 ps aux 更好</p><p>5.Windows 安全日志在哪里？</p><p>当时没回答出来</p><p>答案：计算机 - 管理 - 事件查看器 - Windows 日志 - 安全</p><p>6.目前有用过哪些扫描器？</p><p>Nmap、AWVS、sqlmap、BurpSuite</p><p>当时回答 BurpSuite 说没有扫描功能很尴尬，技术官指出来说 BurpSuite 是现在最好用的扫描器，集成了各种功能，抓包解码重放爆破</p><p>7.有没有实习过</p><p>没有实习过，刚找实习，面试官因此就问我过去新环境有没有问题</p><p>我回答之前社团工作了两年，经常与人沟通，适应能力很好</p><p>8.任意文件读取漏洞产生的原理</p><p>下载功能或者读取文件时候没有对权限进行控制，允许它跳转到 WEB 目录</p><p>9.任意文件读取漏洞正常出现在什么功能点？</p><p>下载功能或者读取文件，查看一些文件的时候</p><p>10.XSS 原理</p><p>XSS 有三种类型(反射型、存储型、DOM 型)，原理是因为没有过滤客户端提交的数据，被利用后回显到平台</p><p>11.有没有利用过 XSS 平台</p><p>没有……</p><p>12.目前有接触过什么病毒木马吗</p><p><em>WannaCry</em>病毒</p><p>13.病毒环境有哪些特征？病毒的一些特征（除了勒索软件，比如挖矿有什么特征）</p><p>CPU利用资源特别高、不停的发包</p><p>面试官解释这属于网络行为，挖矿会请求矿池，可以通过抓包的方式观察是不是一直在访问矿池，可以确认是不是有挖矿行为</p><p>本机上可能有蠕虫行为、肯定会扩散，植入一堆挖矿病毒</p><p>本机上以防你删除掉查杀掉，还会有一些自启动服务防止被删除</p><p>14.祖籍在哪里</p><p>15.平时有没有处理过 EXCEL 和 WORD，有没有做过一些数据统计或者数据分析</p><p>有的，用过Python数据分析，EXCEL基本操作快捷键都会</p><p>16.EXCEL函数有用过哪些？</p><p>sum、mid、count、if、lookup</p><p>17.是不是打算走普通实习，要不要考虑走校招，再过两轮面试</p><p>走实习，我就问有没有机会转正，面试官说有，看实习表现</p><p>18.问我有没有用过 Java</p><p>没有</p><p>19.问我有没有考虑过在家那边找工作</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;360企业安全-福建分公司安全实习生面试经验&lt;br&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://yanjin.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>携程测试实习生面经</title>
    <link href="http://yanjin.io/2018/11/15/interviewCtrip/"/>
    <id>http://yanjin.io/2018/11/15/interviewCtrip/</id>
    <published>2018-11-15T01:42:58.897Z</published>
    <updated>2019-01-20T11:53:42.266Z</updated>
    
    <content type="html"><![CDATA[<p>一个啥也不会的菜鸡强行转测试的面试经验<br><a id="more"></a></p><h2 id="面试时间及岗位"><a href="#面试时间及岗位" class="headerlink" title="面试时间及岗位"></a>面试时间及岗位</h2><p>时间：2018 年 11 月 14 日 晚上 6 点</p><p>岗位：携程测试实习生</p><h2 id="HR一面"><a href="#HR一面" class="headerlink" title="HR一面"></a>HR一面</h2><p>1.是否找到了实习，因为捞我的简历起来已经过了一个星期，怕我已经找到实习了</p><p>2.还问我是否愿意接受测试的岗位，因为看到我之前有做过一些开发项目</p><p>3.约技术面试时间</p><h2 id="技术官二面"><a href="#技术官二面" class="headerlink" title="技术官二面"></a>技术官二面</h2><p>1.自我介绍一下</p><p>2.让我依次介绍我的项目干了什么</p><p>3.让我看一段代码，代码就不放出来，可能涉及公司隐私，不难</p><p>4.让我打开携程首页，问我一个机票的界面这里需要测试什么</p><p>然后面试官问我还有什么要问的吗？我就问还要不要继续面试，她说没有了，基本可以了，问我几时可以到岗，最长可以实习多久</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>想去携程是因为感觉公司比较大，投测试是因为比较好进，开发岗位的话自己基础不够好很容易给刷，但是还没考虑好去不去携程。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;一个啥也不会的菜鸡强行转测试的面试经验&lt;br&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://yanjin.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>金山服务端开发实习面试总结</title>
    <link href="http://yanjin.io/2018/05/14/interviewWPS/"/>
    <id>http://yanjin.io/2018/05/14/interviewWPS/</id>
    <published>2018-05-14T02:42:19.000Z</published>
    <updated>2019-01-20T11:58:28.632Z</updated>
    
    <content type="html"><![CDATA[<p>人生中的第一次面试打击，但是收获也很大！<br><a id="more"></a></p><h1 id="面试时间及岗位"><a href="#面试时间及岗位" class="headerlink" title="面试时间及岗位"></a>面试时间及岗位</h1><p>时间：2018 年 5 月 14 日 上午 10 点 </p><p>岗位：金山办公软件服务端开发工程师实习生</p><h1 id="面试问题"><a href="#面试问题" class="headerlink" title="面试问题"></a>面试问题</h1><p>以下文字和面试时候问题不一定一摸一样，靠记忆补充的。</p><p>问：你会 CSS3 吗？</p><p>答：不会</p><p>问：你会 JS 吗</p><p>答：不会</p><p>问：那这个岗位需要这两个技能啊</p><p>答：但是我可以很快学习这两个，我自学能力比较好。比如说我做的那个微信公众号查询形势与政策的功能，只花了 10 天左右。</p><p>问：一般人学 Python 3 天就够啦</p><p>我：……</p><p>面试官看了看我项目的经历写着创业基础一键刷课，抢课助手。问我为什么要写这些程序，创业基础课程本来就是学生要学生听课的，你这样子等同于作弊。</p><p>我：…..（我就是想锻炼一下技术，帮帮别人。但是面试官说的太有道理了，我没话说，只好赞同。这种课上了有啥用？）</p><p>面试官：你这个是政治不正确</p><p>我：……</p><p>面试官：你为什么要写这个教学平台的一键查询程序呢？</p><p>我：为了方便大家查询，之前同学们如果有几门作业未提交，就需要一个一个点进去看，很不方便。我的这个程序可以直接一次显示完全部科目的未提交作业。</p><p>面试官：那你这样为什么不直接跟开发厂商反应，让他们提升用户体验呢？你现在这个程序有人用吗？写了几天花费这么多时间，但是没有实际用途。</p><p>我：我想过写成微信小程序给大家用……</p><p>面试官：你为什么要在你的简历上写这么多社团经历，在大学里面花这么多时间去社团，这些社团经历跟你写代码有关系吗？</p><p>我：但是加入了社团锻炼了我沟通能力，社交能力啊。</p><p>面试官：那这些能力和写代码能力有关系吗？</p><p>我：……</p><p>我：面试官，那我给您看看我的成绩单。之前因为在社团也没有好好学习，但现在退出后一直在好好学习，每学期都在进步，从 2.6, 3.1, 3.5 再到 4.1 。说明我的学习能力还是可以的。</p><p>面试官：但是你可以看看班上一些女孩子，学习成绩很好，但是写代码不行啊。这个也跟写代码能力没有关系。</p><p>我：……</p><p>面试官：那还是来点实际的，你说一下二分查找的算法。</p><p>我：一开始说了直接从中间开始查找，但是根本还没排序。想到排序了，但是不会写冒泡排序的算法了。</p><p>没答出来面试官就直接走了，说面试结束。我知道自己肯定挂了，等了许久 HR 也没来，我就直接走了。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><h2 id="1-刷题刷题刷题！"><a href="#1-刷题刷题刷题！" class="headerlink" title="1.刷题刷题刷题！"></a>1.刷题刷题刷题！</h2><p>我的数据结构一点都没学，也没去刷题，这个是面试失败最根本的原因。我之前复习的策略都在简历上的知识点，没有弄面试的算法题，这个致命伤。</p><h2 id="2-简历上的项目"><a href="#2-简历上的项目" class="headerlink" title="2.简历上的项目"></a>2.简历上的项目</h2><p>不要写那些带有违反规定或者政治不正确的项目。比如我这次的抢课助手和刷课项目，我也得承认这两个东西违反了一些规定，但是学技术的人难道就没有 Geek 精神吗？你可以测试，但是不能有盈利就好了。</p><h2 id="3-社团经历"><a href="#3-社团经历" class="headerlink" title="3.社团经历"></a>3.社团经历</h2><p>如果是面试技术岗位，能不写还是不写了吧。面试官对社团经历的个人偏好完全影响了他对你的个人印象。有的面试官可能喜欢社会实践经验多的，有的面试官完全不喜欢。</p><p>说到社团就是一把辛酸泪，感觉两年的付出给这个面试官全抛否定了。但我知道我收获了什么，见世面，沟通能力，协调能力，这是写代码能带来的？</p><p>不是，这些能力才是社会上更重要的技能。</p><p>写代码是一定要很熟练的，但是只会写代码是不行的。</p><p>不过也看得出来，我现在是连写代码都不会的人哈哈哈！本末倒置。</p><h2 id="4-大学成绩"><a href="#4-大学成绩" class="headerlink" title="4.大学成绩"></a>4.大学成绩</h2><p>金山的这个面试官不看重成绩，看重的是写代码的能力。</p><p>我也知道一个朋友的朋友，就会因为项目经验多，写代码能力强去了小米。虽然挂科很多，成绩很差。</p><p>这也从侧面体现出了互联网公司对于大学成绩的看法。</p><p>但是从我自己的角度来看，如果想继续读研究生，成绩还是非常重要的。你有成绩至少有几条路可以选，没有成绩就只能工作了，或者你很有钱去国外留学。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;人生中的第一次面试打击，但是收获也很大！&lt;br&gt;
    
    </summary>
    
    
      <category term="面试" scheme="http://yanjin.io/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>如何写一篇永远保存在这个世界中的文章</title>
    <link href="http://yanjin.io/2018/04/26/foreverArticle/"/>
    <id>http://yanjin.io/2018/04/26/foreverArticle/</id>
    <published>2018-04-26T03:41:18.000Z</published>
    <updated>2019-01-20T11:52:00.935Z</updated>
    
    <content type="html"><![CDATA[<p>本文介绍了如何购买电子货币和区块链记录文章方法<br><a id="more"></a></p><h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>最近我们身边发生了很多事情，比如说北大岳欣事件，比如说武汉理工大学研究生因为导师欺压跳楼事件等等。这里面经常发生的一件事情是，人们的发声被删除。比如说你写的公众号文章，或者是帖子，很容易就从网络上抹除了痕迹。</p><p>但直到前几天我看到了一篇文章，它介绍了区块链的一个应用,才有了一个比较完美的解决方法。我们可以利用区块链来记录我们的文章。</p><h1 id="区块链"><a href="#区块链" class="headerlink" title="区块链"></a>区块链</h1><blockquote><p>一句话，它是一种特殊的分布式数据库。</p></blockquote><blockquote><p>首先，区块链的主要作用是储存信息。任何需要保存的信息，都可以写入区块链，也可以从里面读取，所以它是数据库。</p></blockquote><blockquote><p>其次，任何人都可以架设服务器，加入区块链网络，成为一个节点。区块链的世界里面，没有中心节点，每个节点都是平等的，都保存着整个数据库。你可以向任何一个节点，写入/读取数据，因为所有节点最后都会同步，保证区块链一致。</p></blockquote><blockquote><p>区块链没有管理员，它是彻底无中心的。其他的数据库都有管理员，但是区块链没有。如果有人想对区块链添加审核，也实现不了，因为它的设计目标就是防止出现居于中心地位的管理当局。</p></blockquote><blockquote><p>正是因为无法管理，区块链才能做到无法被控制。否则一旦大公司大集团控制了管理权，他们就会控制整个平台，其他使用者就都必须听命于他们了。</p></blockquote><p>引用来自：<a href="http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/12/blockchain-tutorial.html</a></p><p>所以，我们利用区块链的不可删除性，来记录我们的文章。那么什么时候需要利用这个特性呢？那就是当你遇到了不公平的对待，需要在这个世界上，在网络发声的时候。当然，我们假设你所面对的不公是真实的，不是伪造的。</p><p>也许有的人在此时此刻说的谎话被人们当真了。可若你在区块链中记录了这一件事情，一百年后，事情的真相还是会水落石出。</p><h1 id="区块链记录方法"><a href="#区块链记录方法" class="headerlink" title="区块链记录方法"></a>区块链记录方法</h1><p>我自己是从某一个交易平台买了 100 RMB 以太坊币，然后从交易平台转账到我自己的钱包。至于要怎么买币，就留给大家去谷歌了。希望大家能够试一试这个探索的过程。因为直接得到的答案并不会深刻。但我就被坑了，从交易平台提现到钱包又要收手续费，把以太坊币换成人民币大概是 40+ RMB。</p><p>因此，首先你要有以太坊币，有了币之后你就可以发起转账了。而且买币之前你最好要有一个电子钱包，我用的是 imToken。</p><p>不过这个钱包不能自己给自己转账，我的方法就是安卓多开这个软件，创建了两个钱包，我就通过一个钱包转账给另外一个钱包。另外因为转账本身是需要给矿工手续费的，你把数据记录在区块链上，总要有人来处理吧。那就是矿工，矿工的收益除了自己挖到的币，还有就是这种交易费。</p><p>对于要记录的内容，英文内容可以直接转成 16 进制码，中文内容则要以 UTF-8 码的字符串形式转为 16 进制码。</p><p>转换网址：<a href="http://tool.haooyou.com/code?group=convert&amp;type=strToHex&amp;charset=UTF-8" target="_blank" rel="noopener">http://tool.haooyou.com/code?group=convert&amp;type=strToHex&amp;charset=UTF-8</a></p><p>所以我要先把自己这篇的文章以 UTF-8 码的字符串形式转为 16 进制码，最后还要在代码之前加上固定头部“0x”以表示 16 进制。</p><p>为了能够记录我们的文章，转账的时候要选择高级选项，这样我们才能把这个内容记录在区块链中。要记得千万不要把内容写在「<strong>备注</strong>」里面，要写在高级选项的十六进制数据中。</p><p>高级选项会让你自定义 Gas Price和 Gas Limit。 一笔转账需要花费矿工费 =  Gas Price * Gas Limit。通常情况下，如果有人只说 Gas ，指的就是 Gas Limit，Gas Limitt 相当于汽车需要加多少汽油， Gas Price 相当于每升汽油的价格。</p><p>因为我这篇文章的字数接近 1500 字，所以这一次我输入的 Gas Limit 为 3000000，Gas Price 为 2 gwei。你必须包括足够的 gas 来支付计算资源，否则由于 Gas 不够报错 Out of gas。但最后我这个就没花完，所有未使用的 gas 在转账结束时退还了。</p><p>我试了一下，1500 左右的字矿工手续费大概需要人民币 7 块钱左右，也不贵。大家少喝两瓶饮料，就能让你的文章永远记录下来了。然后会得到最重要的 Hash 值，它是一长串数字字母。它是这个记录的凭据，你可以用各种方法把它记录下来。因为之后你可以在任何一个以太坊的节点中查询到你曾经记录过的信息。</p><p>以太坊查询网址：<a href="https://etherscan.io" target="_blank" rel="noopener">https://etherscan.io</a></p><p>在这里输入那串转账记录的 Hash 值，就可以看到你记录的文章啦。</p><h1 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h1><p>我从过去这些事件得到最大的一个启发是，我们面前没有绝对的真相。你会发现呈现在你面前的数据都是别人想给你看到的。很多新闻，一开始是这个风向，说这个不好那个不好，某某的错。后来一研究，一推敲，发现很多地方是错的。</p><p>那么，上面的这种情况可能就要要求新闻工作者们有更高的追求。作为程序员，也要有自己的要求。我希望自己要有职业操守，和道德的修养。我们这一代最聪明的人，最顶尖的人，如果都去弄广告的算法，想着如何让人去点击广告，我个人觉得是一个很令人害怕的事情。</p><p>所以我希望能够做一些真正意义上有用的工具给大家，去改善我们的生活，去改变这个世界。</p><p>最后我把这文章记录在以太坊区块链上，如果有一天这个博客不在了，拿着那串 Hash 值还能看到我写下来的文字。</p><p><a href="https://etherscan.io/tx/0x6ba91b389726c26116816bc5eba0d474c4a3f3af066078d294d36fe86c11dac5" target="_blank" rel="noopener">本文区块链查询地址</a></p><p>Hash：6ba91b389726c26116816bc5eba0d474c4a3f3af066078d294d36fe86c11dac5 </p><p>参考方法和引用来自：<a href="http://www.wdk.pw/1410.html" target="_blank" rel="noopener">http://www.wdk.pw/1410.html</a></p><p><a href="http://www.pingwest.com/how-to-post-blog-on-blockchain/" target="_blank" rel="noopener">http://www.pingwest.com/how-to-post-blog-on-blockchain/</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文介绍了如何购买电子货币和区块链记录文章方法&lt;br&gt;
    
    </summary>
    
    
      <category term="区块链" scheme="http://yanjin.io/tags/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
  </entry>
  
  <entry>
    <title>微信公众号推文永久链接爬虫</title>
    <link href="http://yanjin.io/2018/04/26/wechatArticleSpider/"/>
    <id>http://yanjin.io/2018/04/26/wechatArticleSpider/</id>
    <published>2018-04-26T03:41:18.000Z</published>
    <updated>2019-01-20T11:56:46.943Z</updated>
    
    <content type="html"><![CDATA[<p>利用微信公众号后台素材管理－新建图文素材－超链接－查找文章（公众号）的接口实现爬取公众号的所有文章链接<br><a id="more"></a></p><h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>获取某个或多个微信公众号的所有文章，并且文章的链接是永久链接。比如我之前想分析学校公众号的某一个长期栏目，就需要他所有相关推送的文章内容。但是有 100+ 的推送，总不可能一篇一篇文章的去保存它的链接对吧？因此要想办法自动获取到所有的链接，再通过打开链接得到文章内容。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>利用微信公众号后台素材管理－新建图文素材－超链接－查找文章（公众号）的接口。因此，我们要做的就是模拟这个请求。<br>1.Selenium ＋ Webdriver 登陆微信公众平台，获取公众号的Cookie<br>2.登陆之后获取 token 值，因为之后所有请求都需要带 token 这个参数<br>3.模拟搜索公众号，每个公众号有对应的 fakeid，我们要得到公众号的fakeid<br>4.模拟搜索公众号内的文章，self.query 这个值为搜索公众号文章的关键字，默认为空，可以修改为自己想要找的公众号文章标题对应的关键字。此时会返回一个 JSON 包，app_msg_list 中的 link 就是我们要的链接。</p><h2 id="前提"><a href="#前提" class="headerlink" title="前提"></a>前提</h2><p>你要有一个自己的微信公众号（订阅号）<br>Python环境：Python3</p><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><p>修改 wechat_official_accounts 为想要搜索公众号的微信号，支持多个微信号<br>修改 username 为自己订阅号的账号<br>修改 password 为自己订阅号的密码<br>修改 self.query 为自己想要搜索的公众号文章标题对应的关键字<br>修改 self.driver = webdriver.Firefox(executable_path=’/Users/zl/Downloads/geckodriver’) 为自己对应的 geckodriver 内核地址，也可以使用 Chrome 浏览器</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>Talk is cheap，show you my code。<br>Github 项目代码地址: <a href="https://github.com/ttys0001/wechat-spider" target="_blank" rel="noopener">https://github.com/ttys0001/wechat-spider</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br></pre></td><td class="code"><pre><span class="line">import time</span><br><span class="line">import requests</span><br><span class="line">import json</span><br><span class="line">import re</span><br><span class="line">import random</span><br><span class="line">from selenium import webdriver</span><br><span class="line"></span><br><span class="line">class WechatArticleUrl:</span><br><span class="line"></span><br><span class="line">    def __init__(self,wechat_official_accounts,username,password):</span><br><span class="line">        self.wechat_official_accounts = wechat_official_accounts</span><br><span class="line">        self.article_url_list = []</span><br><span class="line">        self.driver = webdriver.Firefox(executable_path=&apos;/Users/zl/Downloads/geckodriver&apos;)</span><br><span class="line">        self.account_str = [username, password]</span><br><span class="line">        self.cookies = &#123;&#125;</span><br><span class="line">        self.token = &apos;&apos;</span><br><span class="line">        self.header = &#123;</span><br><span class="line">            &quot;HOST&quot;: &quot;mp.weixin.qq.com&quot;,</span><br><span class="line">            &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:53.0) Gecko/20100101 Firefox/53.0&quot;</span><br><span class="line">        &#125;</span><br><span class="line">        self.query = &apos;&apos;</span><br><span class="line"></span><br><span class="line">    def __main__(self):</span><br><span class="line">        self.login_wechat_official()</span><br><span class="line">        self.get_token()</span><br><span class="line">        self.get_url()</span><br><span class="line"></span><br><span class="line">    def login_wechat_official(self):</span><br><span class="line">        self.driver.get(&apos;https://mp.weixin.qq.com/&apos;)</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        # ============登录，获取cookie</span><br><span class="line">        self.driver.find_element_by_name(&apos;account&apos;).clear()</span><br><span class="line">        self.driver.find_element_by_name(&apos;account&apos;).send_keys(self.account_str[0])</span><br><span class="line">        self.driver.find_element_by_name(&apos;password&apos;).clear()</span><br><span class="line">        self.driver.find_element_by_name(&apos;password&apos;).send_keys(self.account_str[1])</span><br><span class="line">        # 在自动输完密码之后记得点一下记住我</span><br><span class="line">        time.sleep(2)</span><br><span class="line">        self.driver.find_element_by_xpath(&quot;./*//a[@class=&apos;btn_login&apos;]&quot;).click()</span><br><span class="line">        # 拿手机扫二维码！</span><br><span class="line">        time.sleep(10)</span><br><span class="line">        self.driver.get(&apos;https://mp.weixin.qq.com/&apos;)</span><br><span class="line">        cookie_items = self.driver.get_cookies()</span><br><span class="line">        for cookie_item in cookie_items:</span><br><span class="line">            self.cookies[cookie_item[&apos;name&apos;]] = cookie_item[&apos;value&apos;]</span><br><span class="line"></span><br><span class="line">    def get_token(self):</span><br><span class="line">        url = &apos;https://mp.weixin.qq.com&apos;</span><br><span class="line">        response = requests.get(url=url, cookies=self.cookies)</span><br><span class="line">        self.token = re.findall(r&apos;token=(\d+)&apos;, str(response.url))[0]</span><br><span class="line"></span><br><span class="line">    def get_fakeid(self,query):</span><br><span class="line">        query_id = &#123;</span><br><span class="line">            &apos;action&apos;: &apos;search_biz&apos;,</span><br><span class="line">            &apos;token&apos;: self.token,</span><br><span class="line">            &apos;lang&apos;: &apos;zh_CN&apos;,</span><br><span class="line">            &apos;f&apos;: &apos;json&apos;,</span><br><span class="line">            &apos;ajax&apos;: &apos;1&apos;,</span><br><span class="line">            &apos;random&apos;: random.random(),</span><br><span class="line">            &apos;query&apos;: query,</span><br><span class="line">            &apos;begin&apos;: &apos;0&apos;,</span><br><span class="line">            &apos;count&apos;: &apos;5&apos;,</span><br><span class="line">        &#125;</span><br><span class="line">        search_url = &apos;https://mp.weixin.qq.com/cgi-bin/searchbiz?&apos;</span><br><span class="line">        search_response = requests.get(search_url, cookies=self.cookies, headers=self.header, params=query_id)</span><br><span class="line">        tmp_url = search_response.url  # 构造结果url</span><br><span class="line">        # print(tmp_url)</span><br><span class="line">        lists = search_response.json().get(&apos;list&apos;)[0]</span><br><span class="line">        # print(lists)</span><br><span class="line">        fakeid = lists.get(&apos;fakeid&apos;)</span><br><span class="line">        return fakeid</span><br><span class="line"></span><br><span class="line">    def get_url(self):</span><br><span class="line">        for query in self.wechat_official_accounts:</span><br><span class="line">            count = 0</span><br><span class="line">            fakeid = self.get_fakeid(query)</span><br><span class="line">            while True:</span><br><span class="line">                query_id_data = &#123;</span><br><span class="line">                    &apos;token&apos;: self.token,</span><br><span class="line">                    &apos;lang&apos;: &apos;zh_CN&apos;,</span><br><span class="line">                    &apos;f&apos;: &apos;json&apos;,</span><br><span class="line">                    &apos;ajax&apos;: &apos;1&apos;,</span><br><span class="line">                    &apos;random&apos;: random.random(),</span><br><span class="line">                    &apos;action&apos;: &apos;list_ex&apos;,</span><br><span class="line">                    &apos;begin&apos;: count,</span><br><span class="line">                    &apos;count&apos;: &apos;10&apos;,</span><br><span class="line">                    &apos;query&apos;: self.query,</span><br><span class="line">                    &apos;fakeid&apos;: fakeid,</span><br><span class="line">                    &apos;type&apos;: &apos;9&apos;</span><br><span class="line">                &#125;</span><br><span class="line">                appmsg_url = &apos;https://mp.weixin.qq.com/cgi-bin/appmsg?&apos;</span><br><span class="line">                appmsg_response = requests.get(appmsg_url, cookies=self.cookies, headers=self.header,params=query_id_data)</span><br><span class="line">                tmp_appmsg_url = appmsg_response.url</span><br><span class="line">                print(tmp_appmsg_url)</span><br><span class="line">                appmsg_response_json = json.loads(appmsg_response.content)</span><br><span class="line">                app_msg_cnt = appmsg_response_json[&apos;app_msg_cnt&apos;]</span><br><span class="line">                print(appmsg_response_json)</span><br><span class="line">                for msg_list in appmsg_response_json[&apos;app_msg_list&apos;]:</span><br><span class="line">                    print(msg_list[&apos;link&apos;])</span><br><span class="line">                    self.article_url_list.append(msg_list[&apos;link&apos;])</span><br><span class="line"></span><br><span class="line">                if app_msg_cnt &lt;= 10 or app_msg_cnt - count &lt;= 10:</span><br><span class="line">                    break</span><br><span class="line">                else:</span><br><span class="line">                    count += 10</span><br><span class="line"></span><br><span class="line">            print(self.article_url_list)</span><br><span class="line">            print(len(self.article_url_list))</span><br><span class="line">            with open(&apos;article_url.txt&apos;, &apos;w&apos;) as file:</span><br><span class="line">                for url in self.article_url_list:</span><br><span class="line">                    file.write(url)</span><br><span class="line">                    file.write(&apos;\n&apos;)</span><br><span class="line"></span><br><span class="line">if __name__ == &apos;__main__&apos;:</span><br><span class="line">    wechat_official_accounts = [&apos;公众号微信号&apos;]</span><br><span class="line">    username = &apos;公众号账号&apos;</span><br><span class="line">    password = &apos;公众号密码&apos;</span><br><span class="line">    wechat_official = WechatArticleUrl(wechat_official_accounts,username,password)</span><br><span class="line">    wechat_official.__main__()</span><br></pre></td></tr></table></figure><p>参考来自：<a href="https://www.jianshu.com/p/adcc630336ae" target="_blank" rel="noopener">https://www.jianshu.com/p/adcc630336ae</a><br></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;利用微信公众号后台素材管理－新建图文素材－超链接－查找文章（公众号）的接口实现爬取公众号的所有文章链接&lt;br&gt;
    
    </summary>
    
    
      <category term="Python爬虫" scheme="http://yanjin.io/tags/Python%E7%88%AC%E8%99%AB/"/>
    
  </entry>
  
</feed>
